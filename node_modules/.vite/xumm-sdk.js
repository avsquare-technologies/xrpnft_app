import {
  __commonJS
} from "./chunk-IGMYUX52.js";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/fetch-ponyfill/build/fetch-browser.js
var require_fetch_browser = __commonJS({
  "node_modules/fetch-ponyfill/build/fetch-browser.js"(exports, module) {
    (function(global2) {
      "use strict";
      function fetchPonyfill(options) {
        var Promise2 = options && options.Promise || global2.Promise;
        var XMLHttpRequest = options && options.XMLHttpRequest || global2.XMLHttpRequest;
        return function() {
          var globalThis2 = Object.create(global2, {
            fetch: {
              value: void 0,
              writable: true
            }
          });
          (function(global3, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.WHATWGFetch = {});
          })(this, function(exports2) {
            "use strict";
            var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
            var support = {
              searchParams: "URLSearchParams" in global3,
              iterable: "Symbol" in global3 && "iterator" in Symbol,
              blob: "FileReader" in global3 && "Blob" in global3 && function() {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              }(),
              formData: "FormData" in global3,
              arrayBuffer: "ArrayBuffer" in global3
            };
            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            }
            if (support.arrayBuffer) {
              var viewClasses = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]"
              ];
              var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
              };
            }
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            function iteratorFor(items) {
              var iterator = {
                next: function() {
                  var value = items.shift();
                  return { done: value === void 0, value };
                }
              };
              if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                  return iterator;
                };
              }
              return iterator;
            }
            function Headers(headers) {
              this.map = {};
              if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }
            Headers.prototype.append = function(name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ", " + value : value;
            };
            Headers.prototype["delete"] = function(name) {
              delete this.map[normalizeName(name)];
            };
            Headers.prototype.get = function(name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };
            Headers.prototype.has = function(name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };
            Headers.prototype.set = function(name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };
            Headers.prototype.forEach = function(callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };
            Headers.prototype.keys = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };
            Headers.prototype.values = function() {
              var items = [];
              this.forEach(function(value) {
                items.push(value);
              });
              return iteratorFor(items);
            };
            Headers.prototype.entries = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };
            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }
            function consumed(body) {
              if (body.bodyUsed) {
                return Promise2.reject(new TypeError("Already read"));
              }
              body.bodyUsed = true;
            }
            function fileReaderReady(reader) {
              return new Promise2(function(resolve, reject) {
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  reject(reader.error);
                };
              });
            }
            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }
            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }
            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);
              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join("");
            }
            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }
            function Body() {
              this.bodyUsed = false;
              this._initBody = function(body) {
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = "";
                } else if (typeof body === "string") {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get("content-type")) {
                  if (typeof body === "string") {
                    this.headers.set("content-type", "text/plain;charset=UTF-8");
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set("content-type", this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                  }
                }
              };
              if (support.blob) {
                this.blob = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return Promise2.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise2.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as blob");
                  } else {
                    return Promise2.resolve(new Blob([this._bodyText]));
                  }
                };
                this.arrayBuffer = function() {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                      return isConsumed;
                    }
                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise2.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                    } else {
                      return Promise2.resolve(this._bodyArrayBuffer);
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }
              this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise2.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as text");
                } else {
                  return Promise2.resolve(this._bodyText);
                }
              };
              if (support.formData) {
                this.formData = function() {
                  return this.text().then(decode);
                };
              }
              this.json = function() {
                return this.text().then(JSON.parse);
              };
              return this;
            }
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }
            function Request(input, options2) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              options2 = options2 || {};
              var body = options2.body;
              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError("Already read");
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options2.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }
              this.credentials = options2.credentials || this.credentials || "same-origin";
              if (options2.headers || !this.headers) {
                this.headers = new Headers(options2.headers);
              }
              this.method = normalizeMethod(options2.method || this.method || "GET");
              this.mode = options2.mode || this.mode || null;
              this.signal = options2.signal || this.signal;
              this.referrer = null;
              if ((this.method === "GET" || this.method === "HEAD") && body) {
                throw new TypeError("Body not allowed for GET or HEAD requests");
              }
              this._initBody(body);
              if (this.method === "GET" || this.method === "HEAD") {
                if (options2.cache === "no-store" || options2.cache === "no-cache") {
                  var reParamSearch = /([?&])_=[^&]*/;
                  if (reParamSearch.test(this.url)) {
                    this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
                  } else {
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
                  }
                }
              }
            }
            Request.prototype.clone = function() {
              return new Request(this, { body: this._bodyInit });
            };
            function decode(body) {
              var form = new FormData();
              body.trim().split("&").forEach(function(bytes) {
                if (bytes) {
                  var split = bytes.split("=");
                  var name = split.shift().replace(/\+/g, " ");
                  var value = split.join("=").replace(/\+/g, " ");
                  form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
              });
              return form;
            }
            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
              preProcessedHeaders.split("\r").map(function(header) {
                return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
              }).forEach(function(line) {
                var parts = line.split(":");
                var key = parts.shift().trim();
                if (key) {
                  var value = parts.join(":").trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }
            Body.call(Request.prototype);
            function Response(bodyInit, options2) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              if (!options2) {
                options2 = {};
              }
              this.type = "default";
              this.status = options2.status === void 0 ? 200 : options2.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = "statusText" in options2 ? options2.statusText : "";
              this.headers = new Headers(options2.headers);
              this.url = options2.url || "";
              this._initBody(bodyInit);
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };
            Response.error = function() {
              var response = new Response(null, { status: 0, statusText: "" });
              response.type = "error";
              return response;
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError("Invalid status code");
              }
              return new Response(null, { status, headers: { location: url } });
            };
            exports2.DOMException = global3.DOMException;
            try {
              new exports2.DOMException();
            } catch (err) {
              exports2.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };
              exports2.DOMException.prototype = Object.create(Error.prototype);
              exports2.DOMException.prototype.constructor = exports2.DOMException;
            }
            function fetch(input, init) {
              return new Promise2(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                  return reject(new exports2.DOMException("Aborted", "AbortError"));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                  xhr.abort();
                }
                xhr.onload = function() {
                  var options2 = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                  };
                  options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                  var body = "response" in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function() {
                    resolve(new Response(body, options2));
                  }, 0);
                };
                xhr.onerror = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.ontimeout = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.onabort = function() {
                  setTimeout(function() {
                    reject(new exports2.DOMException("Aborted", "AbortError"));
                  }, 0);
                };
                function fixUrl(url) {
                  try {
                    return url === "" && global3.location.href ? global3.location.href : url;
                  } catch (e) {
                    return url;
                  }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === "include") {
                  xhr.withCredentials = true;
                } else if (request.credentials === "omit") {
                  xhr.withCredentials = false;
                }
                if ("responseType" in xhr) {
                  if (support.blob) {
                    xhr.responseType = "blob";
                  } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                    xhr.responseType = "arraybuffer";
                  }
                }
                if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }
                if (request.signal) {
                  request.signal.addEventListener("abort", abortXhr);
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener("abort", abortXhr);
                    }
                  };
                }
                xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
              });
            }
            fetch.polyfill = true;
            if (!global3.fetch) {
              global3.fetch = fetch;
              global3.Headers = Headers;
              global3.Request = Request;
              global3.Response = Response;
            }
            exports2.Headers = Headers;
            exports2.Request = Request;
            exports2.Response = Response;
            exports2.fetch = fetch;
            Object.defineProperty(exports2, "__esModule", { value: true });
          });
          return {
            fetch: globalThis2.fetch,
            Headers: globalThis2.Headers,
            Request: globalThis2.Request,
            Response: globalThis2.Response,
            DOMException: globalThis2.DOMException
          };
        }();
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return fetchPonyfill;
        });
      } else if (typeof exports === "object") {
        module.exports = fetchPonyfill;
      } else {
        global2.fetchPonyfill = fetchPonyfill;
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports);
  }
});

// node_modules/os-browserify/browser.js
var require_browser2 = __commonJS({
  "node_modules/os-browserify/browser.js"(exports) {
    exports.endianness = function() {
      return "LE";
    };
    exports.hostname = function() {
      if (typeof location !== "undefined") {
        return location.hostname;
      } else
        return "";
    };
    exports.loadavg = function() {
      return [];
    };
    exports.uptime = function() {
      return 0;
    };
    exports.freemem = function() {
      return Number.MAX_VALUE;
    };
    exports.totalmem = function() {
      return Number.MAX_VALUE;
    };
    exports.cpus = function() {
      return [];
    };
    exports.type = function() {
      return "Browser";
    };
    exports.release = function() {
      if (typeof navigator !== "undefined") {
        return navigator.appVersion;
      }
      return "";
    };
    exports.networkInterfaces = exports.getNetworkInterfaces = function() {
      return {};
    };
    exports.arch = function() {
      return "javascript";
    };
    exports.platform = function() {
      return "browser";
    };
    exports.tmpdir = exports.tmpDir = function() {
      return "/tmp";
    };
    exports.EOL = "\n";
    exports.homedir = function() {
      return "/";
    };
  }
});

// node_modules/xumm-sdk/dist/src/utils.js
var require_utils = __commonJS({
  "node_modules/xumm-sdk/dist/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeferredPromise = exports.throwIfError = void 0;
    function throwIfError(call) {
      var _a, _b, _c, _d, _e, _f;
      const isFatalError = call.message !== void 0;
      if (isFatalError) {
        throw new Error(call.message);
      }
      const isError = call.next === void 0 && ((_b = (_a = call) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.uuid) === void 0 && ((_d = (_c = call) === null || _c === void 0 ? void 0 : _c.application) === null || _d === void 0 ? void 0 : _d.uuidv4) === void 0 && ((_f = (_e = call) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.code) !== void 0;
      if (isError) {
        const e = call.error;
        throw new Error(`Error code ${e.code}, see XUMM Dev Console, reference: ${e.reference}`);
      }
    }
    exports.throwIfError = throwIfError;
    var DeferredPromise = class {
      constructor() {
        this.resolveFn = (_arg) => {
        };
        this.rejectFn = (_arg) => {
        };
        this.promise = new Promise((resolve, reject) => {
          this.resolveFn = resolve;
          this.rejectFn = reject;
        });
      }
      resolve(arg) {
        this.resolveFn(arg);
        return this.promise;
      }
      reject(arg) {
        this.rejectFn(arg);
        return this.promise;
      }
    };
    exports.DeferredPromise = DeferredPromise;
  }
});

// node_modules/xumm-sdk/dist/src/Meta.js
var require_Meta = __commonJS({
  "node_modules/xumm-sdk/dist/src/Meta.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Meta = void 0;
    var debug_1 = require_browser();
    var fetch_ponyfill_1 = __importDefault(require_fetch_browser());
    var { fetch, Request, Response, Headers } = fetch_ponyfill_1.default();
    var os_browserify_1 = require_browser2();
    var utils_1 = require_utils();
    var index_1 = require_src();
    var log = debug_1.debug("xumm-sdk:meta");
    var Meta = class {
      constructor(apiKey, apiSecret) {
        this.isBrowser = false;
        this.jwtFlow = false;
        this.injected = false;
        this.endpoint = "https://xumm.app";
        log("Constructed");
        const uuidRe = new RegExp("^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$");
        const secret = {
          split: apiSecret.split(":"),
          uuidv4: ""
        };
        if (secret.split.length === 3 && secret.split.slice(0, 2).join(":") === "xApp:OneTimeToken") {
          secret.uuidv4 = secret.split[2];
          this.jwtFlow = true;
        } else if (secret.split.length > 1 && secret.split[0] === "RAWJWT") {
          this.jwtFlow = true;
          this.jwt = secret.split.slice(1).join(":");
        } else {
          secret.uuidv4 = apiSecret;
        }
        if (!uuidRe.test(apiKey) || !uuidRe.test(secret.uuidv4)) {
          if (!this.jwtFlow) {
            throw new Error("Invalid API Key and/or API Secret. Use dotenv or constructor params.");
          } else {
            if (!this.jwt) {
              throw new Error("Invalid API Key and/or OTT (One Time Token). Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)");
            }
          }
        }
        if (typeof globalThis !== "undefined" && Object.keys(globalThis).indexOf("window") < 0) {
          log("Running in node");
        } else {
          console.log("XUMM SDK: Running in browser");
          this.isBrowser = true;
        }
        this.apiKey = apiKey;
        this.apiSecret = secret.uuidv4;
        if (this.jwtFlow && !this.jwt) {
          this.authPromise = new Promise((resolve) => {
            this.authPromiseResolve = resolve;
          });
          Promise.resolve().then(() => this.authorize()).catch((e) => {
            log("Authorize error:", e.message);
            if (this === null || this === void 0 ? void 0 : this.invoker) {
              this.invoker.caught(e);
            }
            if (this.authPromiseResolve) {
              this.authPromiseResolve();
            }
          });
        }
        return this;
      }
      setEndpoint(endpoint) {
        if (endpoint.match(/^http/)) {
          this.endpoint = endpoint.trim();
          return true;
        }
        return false;
      }
      authorize() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
          log("JWT Authorize", this.apiSecret);
          let store;
          if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt) {
            store = this.invoker._jwtStore(this, (jwt) => this.jwt = jwt);
          }
          const authorizeData = (store === null || store === void 0 ? void 0 : store.get(this.apiSecret)) || (yield this.call("authorize"));
          if ((_b = (_a = authorizeData) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) {
            log(`Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)`);
            if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt && ((_c = this === null || this === void 0 ? void 0 : this.invoker) === null || _c === void 0 ? void 0 : _c.fatalHandler)) {
              this.invoker.fatalHandler(new Error(authorizeData.error.reference));
            } else {
              utils_1.throwIfError(authorizeData);
            }
          } else if ((_d = authorizeData) === null || _d === void 0 ? void 0 : _d.jwt) {
            const JwtOttResponse = authorizeData;
            store === null || store === void 0 ? void 0 : store.set(this.apiSecret, JwtOttResponse);
          } else {
            throw new Error(`Unexpected response for xApp JWT authorize request`);
          }
          if (this.authPromiseResolve) {
            this.authPromiseResolve();
          }
        });
      }
      call(endpoint, httpMethod = "GET", data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const method = httpMethod.toUpperCase();
          if (this.jwtFlow && !(this === null || this === void 0 ? void 0 : this.jwt) && this.authPromise && endpoint !== "authorize") {
            yield this.authPromise;
          }
          try {
            let body;
            if (typeof data !== "undefined") {
              if (typeof data === "object" && data !== null) {
                body = JSON.stringify(data);
              }
              if (typeof data === "string") {
                body = data;
              }
            }
            const headers = {
              "Content-Type": "application/json"
            };
            if (!this.isBrowser) {
              Object.assign(headers, {
                "User-Agent": `xumm-sdk/node (${os_browserify_1.hostname()}) node-fetch`
              });
            }
            if (!this.jwtFlow) {
              Object.assign(headers, {
                "x-api-key": this.apiKey,
                "x-api-secret": this.apiSecret
              });
            } else {
              if (endpoint === "authorize") {
                Object.assign(headers, {
                  "x-api-key": this.apiKey,
                  "x-api-ott": this.apiSecret
                });
              } else {
                Object.assign(headers, {
                  "Authorization": "Bearer " + this.jwt
                });
              }
            }
            const jwtEndpoints = [
              "authorize",
              "ping",
              "curated-assets",
              "rates",
              "payload",
              "userdata"
            ];
            const endpointType = this.jwtFlow && jwtEndpoints.indexOf(endpoint.split("/")[0]) > -1 ? "jwt" : "platform";
            const request = yield fetch(this.endpoint + "/api/v1/" + endpointType + "/" + endpoint, {
              method,
              body,
              headers
            });
            const json = yield request.json();
            return json;
          } catch (e) {
            const err = new Error(`Unexpected response from XUMM API [${method}:${endpoint}]`);
            err.stack = ((_a = e) === null || _a === void 0 ? void 0 : _a.stack) || void 0;
            throw err;
          }
        });
      }
      ping() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const pong = yield this.call("ping");
          utils_1.throwIfError(pong);
          if (typeof pong.auth !== "undefined") {
            return pong.auth;
          }
          if (typeof ((_a = pong) === null || _a === void 0 ? void 0 : _a.ott_uuidv4) !== "undefined") {
            return {
              application: {
                uuidv4: pong.app_uuidv4,
                name: pong.app_name
              },
              jwtData: pong
            };
          }
          if (typeof ((_b = pong) === null || _b === void 0 ? void 0 : _b.usertoken_uuidv4) !== "undefined") {
            return {
              application: {
                uuidv4: pong.client_id,
                name: pong.app_name
              },
              jwtData: pong
            };
          }
          throw new Error(`Unexpected response for ping request`);
        });
      }
      getCuratedAssets() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("curated-assets");
        });
      }
      getRates(currencyCode) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("rates/" + currencyCode.trim().toUpperCase());
        });
      }
      getKycStatus(userTokenOrAccount) {
        return __awaiter(this, void 0, void 0, function* () {
          if (userTokenOrAccount.trim().match(/^r/)) {
            const call = yield this.call("kyc-status/" + userTokenOrAccount.trim());
            return (call === null || call === void 0 ? void 0 : call.kycApproved) ? "SUCCESSFUL" : "NONE";
          } else {
            const call = yield this.call("kyc-status", "POST", {
              user_token: userTokenOrAccount
            });
            return (call === null || call === void 0 ? void 0 : call.kycStatus) || "NONE";
          }
        });
      }
      getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("xrpl-tx/" + txHash.trim());
        });
      }
      verifyUserTokens(userTokens) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield this.call("user-tokens", "POST", {
            tokens: Array.isArray(userTokens) ? userTokens : [userTokens]
          })).tokens;
        });
      }
      _inject(Invoker) {
        if (!this.injected) {
          this.invoker = Invoker;
        } else {
          throw new Error("Cannot `_inject` twice");
        }
      }
    };
    exports.Meta = Meta;
  }
});

// node_modules/xumm-sdk/dist/src/Storage.js
var require_Storage = __commonJS({
  "node_modules/xumm-sdk/dist/src/Storage.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = void 0;
    var debug_1 = require_browser();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:storage");
    var Storage = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      get() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "GET");
          utils_1.throwIfError(call);
          return call.data;
        });
      }
      set(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "POST", data);
          utils_1.throwIfError(call);
          return call.stored;
        });
      }
      delete() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "DELETE");
          utils_1.throwIfError(call);
          return call.stored;
        });
      }
    };
    exports.Storage = Storage;
  }
});

// node_modules/es5-ext/global.js
var require_global = __commonJS({
  "node_modules/es5-ext/global.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof self === "object" && self)
        return self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this)
        return this;
      if (typeof globalThis === "object" && globalThis)
        return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.34",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module) {
    module.exports = require_package().version;
  }
});

// node_modules/websocket/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/websocket/lib/browser.js"(exports, module) {
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// node_modules/xumm-sdk/dist/src/Payload.js
var require_Payload = __commonJS({
  "node_modules/xumm-sdk/dist/src/Payload.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Payload = void 0;
    var debug_1 = require_browser();
    var websocket_1 = require_browser3();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:payload");
    var logWs = debug_1.debug("xumm-sdk:payload:websocket");
    var Payload = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      resolvePayload(payload) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof payload === "string") {
            return yield this.get(payload, true);
          } else if (typeof ((_a = payload) === null || _a === void 0 ? void 0 : _a.uuid) !== "undefined") {
            return yield this.get(payload.uuid, true);
          } else if (typeof ((_c = (_b = payload) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.uuid) !== "undefined") {
            return payload;
          }
          throw new Error("Could not resolve payload (not found)");
        });
      }
      create(payload, returnErrors = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const directTx = typeof payload.TransactionType !== "undefined" && typeof payload.txjson === "undefined";
          const call = yield this.Meta.call("payload", "POST", directTx ? { txjson: payload } : payload);
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isCreatedPayload = ((_a = call) === null || _a === void 0 ? void 0 : _a.next) !== void 0;
          if (!isCreatedPayload) {
            return null;
          }
          return call;
        });
      }
      get(payload, returnErrors = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const payloadUuid = typeof payload === "string" ? payload : payload === null || payload === void 0 ? void 0 : payload.uuid;
          const call = yield this.Meta.call("payload/" + payloadUuid, "GET");
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isPayload = ((_b = (_a = call) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.uuid) !== void 0;
          if (!isPayload) {
            return null;
          }
          return call;
        });
      }
      subscribe(payload, callback) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const callbackPromise = new utils_1.DeferredPromise();
          const payloadDetails = yield this.resolvePayload(payload);
          if (payloadDetails) {
            const _u = "undefined";
            const socket = typeof ((_a = globalThis) === null || _a === void 0 ? void 0 : _a.MockedWebSocket) !== _u && typeof jest !== _u ? new ((_b = globalThis) === null || _b === void 0 ? void 0 : _b.MockedWebSocket)("ws://xumm.local") : new websocket_1.w3cwebsocket(this.Meta.endpoint.replace(/^http/, "ws") + "/sign/" + payloadDetails.meta.uuid);
            callbackPromise.promise.then(() => {
              socket.close();
            });
            socket.onopen = () => {
              logWs(`Payload ${payloadDetails.meta.uuid}: Subscription active (WebSocket opened)`);
            };
            socket.onmessage = (MessageEvent) => __awaiter(this, void 0, void 0, function* () {
              const m = MessageEvent.data;
              let json = void 0;
              try {
                json = JSON.parse(m.toString());
              } catch (e) {
                logWs(`Payload ${payloadDetails.meta.uuid}: Received message, unable to parse as JSON`, e);
              }
              if (json && callback && typeof json.devapp_fetched === "undefined") {
                try {
                  const callbackResult = yield callback({
                    uuid: payloadDetails.meta.uuid,
                    data: json,
                    resolve(resolveData) {
                      return __awaiter(this, void 0, void 0, function* () {
                        yield callbackPromise.resolve(resolveData || void 0);
                      });
                    },
                    payload: payloadDetails
                  });
                  if (callbackResult !== void 0) {
                    callbackPromise.resolve(callbackResult);
                  }
                } catch (e) {
                  logWs(`Payload ${payloadDetails.meta.uuid}: Callback exception`, e);
                }
              }
            });
            socket.onclose = (_e) => {
              logWs(`Payload ${payloadDetails.meta.uuid}: Subscription ended (WebSocket closed)`);
            };
            return {
              payload: payloadDetails,
              resolve(resolveData) {
                callbackPromise.resolve(resolveData || void 0);
              },
              resolved: callbackPromise.promise,
              websocket: socket
            };
          }
          utils_1.throwIfError(payloadDetails);
          throw Error(`Couldn't subscribe: couldn't fetch payload`);
        });
      }
      cancel(payload, returnErrors = false) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          const fullPayload = yield this.resolvePayload(payload);
          const call = yield this.Meta.call("payload/" + ((_a = fullPayload === null || fullPayload === void 0 ? void 0 : fullPayload.meta) === null || _a === void 0 ? void 0 : _a.uuid), "DELETE");
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isValidResponse = ((_c = (_b = call) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.uuid) !== void 0;
          if (!isValidResponse) {
            return null;
          }
          return call;
        });
      }
      createAndSubscribe(payload, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const createdPayload = yield this.create(payload, true);
          if (createdPayload) {
            const subscription = yield this.subscribe(createdPayload, callback);
            return Object.assign({ created: createdPayload }, subscription);
          }
          throw new Error(`Error creating payload or subscribing to created payload`);
        });
      }
    };
    exports.Payload = Payload;
  }
});

// node_modules/xumm-sdk/dist/src/JwtUserdata.js
var require_JwtUserdata = __commonJS({
  "node_modules/xumm-sdk/dist/src/JwtUserdata.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwtUserdata = void 0;
    var debug_1 = require_browser();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp:userdata");
    var JwtUserdata = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      list() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("userdata", "GET");
          utils_1.throwIfError(call);
          return call.keys;
        });
      }
      get(key) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const keys = Array.isArray(key) ? key.join(",") : key;
          const call = yield this.Meta.call("userdata/" + keys, "GET");
          utils_1.throwIfError(call);
          return keys.split(",").length > 1 ? call.data : ((_a = call.data) === null || _a === void 0 ? void 0 : _a[keys]) || {};
        });
      }
      delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("userdata/" + key, "DELETE");
          utils_1.throwIfError(call);
          return call.persisted;
        });
      }
      set(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("userdata/" + key, "POST", data);
          utils_1.throwIfError(call);
          return call.persisted;
        });
      }
    };
    exports.JwtUserdata = JwtUserdata;
  }
});

// node_modules/xumm-sdk/dist/src/xApp.js
var require_xApp = __commonJS({
  "node_modules/xumm-sdk/dist/src/xApp.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xApp = void 0;
    var debug_1 = require_browser();
    var JwtUserdata_1 = require_JwtUserdata();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp");
    var xApp = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
        this.userdata = new JwtUserdata_1.JwtUserdata(MetaObject);
      }
      get(ott) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/ott/" + ott, "GET");
          utils_1.throwIfError(call);
          return call;
        });
      }
    };
    exports.xApp = xApp;
  }
});

// node_modules/xumm-sdk/dist/src/Push.js
var require_Push = __commonJS({
  "node_modules/xumm-sdk/dist/src/Push.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Push = void 0;
    var debug_1 = require_browser();
    var JwtUserdata_1 = require_JwtUserdata();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp");
    var Push = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
        this.userdata = new JwtUserdata_1.JwtUserdata(MetaObject);
      }
      event(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/event", "POST", data);
          utils_1.throwIfError(call);
          return call;
        });
      }
      notification(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/push", "POST", data);
          utils_1.throwIfError(call);
          return call;
        });
      }
    };
    exports.Push = Push;
  }
});

// node_modules/xumm-sdk/dist/src/index.js
var require_src = __commonJS({
  "node_modules/xumm-sdk/dist/src/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XummSdkJwt = exports.XummSdk = void 0;
    var debug_1 = require_browser();
    var Meta_1 = require_Meta();
    var Storage_1 = require_Storage();
    var Payload_1 = require_Payload();
    var xApp_1 = require_xApp();
    var Push_1 = require_Push();
    var JwtUserdata_1 = require_JwtUserdata();
    var log = debug_1.debug("xumm-sdk");
    var XummSdk = class {
      constructor(apiKey, apiSecret) {
        log("Constructed");
        this.Meta = new Meta_1.Meta(apiKey || this.getEnv("XUMM_APIKEY"), apiSecret || this.getEnv("XUMM_APISECRET"));
        this.storage = new Storage_1.Storage(this.Meta);
        this.payload = new Payload_1.Payload(this.Meta);
        this.jwtUserdata = new JwtUserdata_1.JwtUserdata(this.Meta);
        this.Push = new Push_1.Push(this.Meta);
        this.xApp = new xApp_1.xApp(this.Meta);
        this.Meta._inject(this);
        return this;
      }
      getEnv(arg) {
        let value = "";
        try {
          value = typeof Deno !== "undefined" ? Deno.env.get(arg) || "" : "";
          value = (process === null || process === void 0 ? void 0 : process.env[arg]) || "";
        } catch (_e) {
        }
        return value;
      }
      ping() {
        return this.Meta.ping();
      }
      getCuratedAssets() {
        return this.Meta.getCuratedAssets();
      }
      getRates(currencyCode) {
        return this.Meta.getRates(currencyCode);
      }
      getKycStatus(userTokenOrAccount) {
        return this.Meta.getKycStatus(userTokenOrAccount);
      }
      getTransaction(txHash) {
        return this.Meta.getTransaction(txHash);
      }
      verifyUserTokens(userTokens) {
        return this.Meta.verifyUserTokens(userTokens);
      }
      verifyUserToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
          const tokenResults = yield this.Meta.verifyUserTokens([token]);
          return Array.isArray(tokenResults) && tokenResults.length === 1 ? tokenResults[0] : null;
        });
      }
      setEndpoint(endpoint) {
        return this.Meta.setEndpoint(endpoint);
      }
      caught(error) {
        throw error;
      }
    };
    exports.XummSdk = XummSdk;
    var XummSdkJwt = class extends XummSdk {
      constructor(apiKeyOrJwt, ott, options) {
        var _a, _b, _c, _d, _f, _g, _h, _j;
        let _ott = String(ott || "").trim().toLowerCase();
        const isRawJwt = apiKeyOrJwt.length !== 36;
        if (!isRawJwt) {
          if (typeof ott === "undefined" && typeof window !== "undefined" && typeof window.URLSearchParams !== "undefined") {
            const urlSearchParams = new window.URLSearchParams(((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.search) || "");
            for (const pair of urlSearchParams.entries()) {
              if (pair[0] === "xAppToken") {
                _ott = pair[1].toLowerCase().trim();
              }
            }
            if (_ott === "" && !(options === null || options === void 0 ? void 0 : options.store) && !(options === null || options === void 0 ? void 0 : options.noAutoRetrieve)) {
              if (typeof ((_b = window === null || window === void 0 ? void 0 : window.localStorage) === null || _b === void 0 ? void 0 : _b["XummSdkJwt"]) === "string") {
                try {
                  const localStorageJwtData = (_d = (_c = window === null || window === void 0 ? void 0 : window.localStorage) === null || _c === void 0 ? void 0 : _c["XummSdkJwt"]) === null || _d === void 0 ? void 0 : _d.split(":");
                  const localStorageJwt = JSON.parse((_f = localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData.slice(1)) === null || _f === void 0 ? void 0 : _f.join(":"));
                  if (localStorageJwt === null || localStorageJwt === void 0 ? void 0 : localStorageJwt.jwt) {
                    const jwtContents = JSON.parse(atob((_g = localStorageJwt.jwt.split(".")) === null || _g === void 0 ? void 0 : _g[1]));
                    if (jwtContents === null || jwtContents === void 0 ? void 0 : jwtContents.exp) {
                      const validForSec = (jwtContents === null || jwtContents === void 0 ? void 0 : jwtContents.exp) - Math.floor(new Date().getTime() / 1e3);
                      console.log("Restoring OTT " + (localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData[0]));
                      if (validForSec > 60 * 60) {
                        _ott = localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData[0];
                      } else {
                        console.log("Skip restore: not valid for one more hour");
                      }
                    }
                  }
                } catch (e) {
                  console.log("JWT Restore Error", e);
                }
              }
            }
          }
        }
        super(apiKeyOrJwt, !isRawJwt && _ott !== "" ? "xApp:OneTimeToken:" + _ott : "RAWJWT:" + apiKeyOrJwt);
        this.resolve = (ottData) => {
          log("OTT data resolved", ottData);
        };
        this.reject = (error) => {
          log("OTT data rejected", error.message);
        };
        this.ottResolved = isRawJwt ? Promise.resolve() : new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        if (options === null || options === void 0 ? void 0 : options.fatalHandler) {
          this.fatalHandler = options.fatalHandler;
        }
        this.store = {
          get(uuid) {
            var _a2;
            log("[JwtStore] \xBB Builtin JWT store GET");
            if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
              if (typeof window.localStorage["XummSdkJwt"] === "string") {
                const lsOttData = window.localStorage["XummSdkJwt"].split(":");
                if (lsOttData[0] === uuid) {
                  log("Restoring OTT from localStorage:", uuid);
                  try {
                    return JSON.parse(lsOttData.slice(1).join(":"));
                  } catch (e) {
                    log("Error restoring OTT Data (JWT) from localStorage", (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message);
                  }
                }
              }
            }
          },
          set(uuid, ottData) {
            log("[JwtStore] \xBB Builtin JWT store SET", uuid);
            if (typeof window !== "undefined" && typeof localStorage !== "undefined") {
              window.localStorage["XummSdkJwt"] = uuid + ":" + JSON.stringify(ottData);
            }
          }
        };
        if ((_h = options === null || options === void 0 ? void 0 : options.store) === null || _h === void 0 ? void 0 : _h.get) {
          this.store.get = options.store.get;
        }
        if ((_j = options === null || options === void 0 ? void 0 : options.store) === null || _j === void 0 ? void 0 : _j.set) {
          this.store.set = options.store.set;
        }
        if (isRawJwt) {
          this.reject(new Error("Not in OTT flow: in raw JWT (OAuth2-like) flow"));
          log("Using JWT (Raw, OAuth2) flow");
        } else {
          log("Using JWT (xApp) flow");
        }
      }
      _jwtStore(invoker, persistJwt) {
        if (invoker && (invoker === null || invoker === void 0 ? void 0 : invoker.constructor) === Meta_1.Meta) {
          return {
            get: (uuid) => {
              var _a;
              log("[JwtStore] Proxy GET");
              return (_a = this.store) === null || _a === void 0 ? void 0 : _a.get(uuid);
            },
            set: (uuid, ottData) => {
              var _a;
              log("[JwtStore] Proxy SET");
              this.resolve(ottData.ott);
              persistJwt(ottData.jwt);
              this.jwt = ottData.jwt;
              return (_a = this.store) === null || _a === void 0 ? void 0 : _a.set(uuid, ottData);
            }
          };
        }
        throw new Error("Invalid _jwtStore invoker");
      }
      getOttData() {
        return __awaiter(this, void 0, void 0, function* () {
          const resolved = yield this.ottResolved;
          if (resolved) {
            return resolved;
          }
          throw new Error("Called getOttData on a non OTT-JWT flow");
        });
      }
      getJwt() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ottResolved;
          return this.jwt;
        });
      }
      caught(error) {
        this.reject(error);
      }
    };
    exports.XummSdkJwt = XummSdkJwt;
  }
});

// dep:xumm-sdk
var xumm_sdk_default = require_src();
export {
  xumm_sdk_default as default
};
//# sourceMappingURL=xumm-sdk.js.map
