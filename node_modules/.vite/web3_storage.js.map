{
  "version": 3,
  "sources": ["../web3.storage/src/lib.js", "../ipfs-car/dist/esm/pack/index.js", "../ipfs-car/dist/esm/pack/utils/normalise-input.js", "../ipfs-car/dist/esm/blockstore/memory.js", "../ipfs-car/dist/esm/pack/constants.js", "../@web3-storage/parse-link-header/index.js", "../ipfs-car/dist/esm/unpack/index.js", "../ipfs-unixfs-exporter/esm/src/index.js", "../ipfs-unixfs-exporter/esm/src/resolvers/index.js", "../ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js", "../ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js", "../ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js", "../ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js", "../ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js", "../ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js", "../ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js", "../ipfs-unixfs-exporter/esm/src/resolvers/raw.js", "../ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js", "../ipfs-unixfs-exporter/esm/src/resolvers/identity.js", "../uint8arrays/esm/src/equals.js", "../ipfs-car/dist/esm/unpack/utils/verifying-get-only-blockstore.js", "../files-from-path/esm/src/index.browser.js", "../web3.storage/src/platform.web.js"],
  "sourcesContent": ["/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { pack } from 'ipfs-car/pack'\nimport { parseLinkHeader } from '@web3-storage/parse-link-header'\nimport { unpackStream } from 'ipfs-car/unpack'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { CarReader } from '@ipld/car'\nimport { filesFromPath, getFilesFromPath } from 'files-from-path'\nimport throttledQueue from 'throttled-queue'\nimport {\n  fetch as _fetch,\n  File,\n  Blob,\n  Blockstore\n} from './platform.js'\n\nconst MAX_PUT_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\nconst MAX_BLOCK_SIZE = 1048576\nconst MAX_CHUNK_SIZE = 104857600\n// These match what is enforced server-side\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').RequestOptions} RequestOptions */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').ListOptions} ListOptions */\n/** @typedef { import('./lib/interface.js').RateLimiter } RateLimiter */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * Creates a rate limiter which limits at the same rate as is enforced\n * server-side, to allow the client to avoid exceeding the requests limit and\n * being blocked for 30 seconds.\n * @returns {RateLimiter}\n */\nexport function createRateLimiter () {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the Web3Storage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n    @param {Service} options\n   */\n  constructor ({\n    token,\n    endpoint = new URL('https://api.web3.storage'),\n    rateLimiter,\n    fetch = _fetch\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n    /**\n     * Optional custom fetch function. Defaults to global fetch in browsers or @web-std/fetch on node.\n     * @readonly\n     */\n    this.fetch = fetch\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers (token) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, files, {\n    onRootCidReady,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    wrapWithDirectory = true,\n    name,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const blockstore = new Blockstore()\n    try {\n      const { out, root } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      })\n      onRootCidReady && onRootCidReady(root.toString())\n      const car = await CarReader.fromIterable(out)\n      return await Web3Storage.putCar({ endpoint, token, rateLimiter, fetch }, car, { onStoredChunk, maxRetries, maxChunkSize, name, signal })\n    } finally {\n      await blockstore.close()\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, car, {\n    name,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    decoders,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const targetSize = maxChunkSize\n    const url = new URL('car', endpoint)\n    let headers = Web3Storage.headers(token)\n\n    if (name) {\n      headers = { ...headers, 'X-Name': encodeURIComponent(name) }\n    }\n\n    const roots = await car.getRoots()\n    if (roots[0] == null) {\n      throw new Error('missing root CID')\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots')\n    }\n\n    const carRoot = roots[0].toString()\n    const splitter = new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = []\n      for await (const part of car) {\n        carParts.push(part)\n      }\n\n      const carFile = new Blob(carParts, { type: 'application/vnd.ipld.car' })\n      const res = await pRetry(\n        async () => {\n          await rateLimiter()\n          /** @type {Response} */\n          let response\n          try {\n            response = await fetch(url.toString(), {\n              method: 'POST',\n              headers,\n              body: carFile,\n              signal\n            })\n          } catch (/** @type {any} */err) {\n            throw signal && signal.aborted ? new AbortError(err) : err\n          }\n          /* c8 ignore next 3 */\n          if (response.status === 429) {\n            throw new Error('rate limited')\n          }\n          const res = await response.json()\n          if (!response.ok) {\n            throw new Error(res.message)\n          }\n\n          if (res.cid !== carRoot) {\n            throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`)\n          }\n          return res.cid\n        },\n        { retries: maxRetries }\n      )\n\n      onStoredChunk && onStoredChunk(carFile.size)\n      return res\n    }\n\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk)\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, cid, options = {}) {\n    const url = new URL(`car/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    return toWeb3Response(res)\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete ({ endpoint, token, rateLimiter = globalRateLimiter }, cid, options = {}) {\n    console.log('Not deleting', cid, endpoint, token, rateLimiter, options)\n    throw Error('.delete not implemented yet')\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, cid, options = {}) {\n    const url = new URL(`status/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    if (res.status === 404) {\n      return undefined\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText)\n    }\n    return res.json()\n  }\n\n  /**\n   * @param {Service} service\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  static async * list (service, { before = new Date().toISOString(), maxResults = Infinity, signal } = {}) {\n    /**\n     * @param {Service} service\n     * @param {{before: string, size: number}} opts\n     * @returns {Promise<Response>}\n     */\n    async function listPage ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, { before, size }) {\n      const search = new URLSearchParams({ before, size: size.toString() })\n      const url = new URL(`user/uploads?${search}`, endpoint)\n      await rateLimiter()\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        },\n        signal\n      })\n    }\n    let count = 0\n    const size = maxResults > 100 ? 100 : maxResults\n    for await (const res of paginator(listPage, service, { before, size })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited')\n        }\n\n        /* c8 ignore next 2 */\n        const errorMessage = await res.json()\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`)\n      }\n      const page = await res.json()\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return\n        }\n        yield upload\n      }\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put (files, options) {\n    return Web3Storage.put(this, files, options)\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n\n   *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n\n   *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar (car, options) {\n    return Web3Storage.putCar(this, car, options)\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  get (cid, options) {\n    return Web3Storage.get(this, cid, options)\n  }\n\n  /**\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  /* c8 ignore next 3 */\n  delete (cid, options) {\n    return Web3Storage.delete(this, cid, options)\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  status (cid, options) {\n    return Web3Storage.status(this, cid, options)\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  list (opts) {\n    return Web3Storage.list(this, opts)\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property.\n *\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File ({ content, path, cid }) {\n  const chunks = []\n  for await (const chunk of content()) {\n    chunks.push(chunk)\n  }\n  const file = new File(chunks, toFilenameWithPath(path))\n  return Object.assign(file, { cid: cid.toString() })\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath (unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/')\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1)\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response (res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function * () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`)\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response')\n      }\n      const blockstore = new Blockstore()\n      try {\n        for await (const entry of unpackStream(res.body, { blockstore })) {\n          yield entry\n        }\n      } finally {\n        await blockstore.close()\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`)\n      }\n      const files = []\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue\n        }\n        const file = await toWeb3File(entry)\n        files.push(file)\n      }\n      return files\n    }\n  })\n  return response\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate (file) {\n  /** @type {ReadableStream} */\n  let stream\n  return {\n    path: file.name,\n    get content () {\n      stream = stream || file.stream()\n      return stream\n    }\n  }\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function * paginator (fn, service, opts) {\n  let res = await fn(service, opts)\n  yield res\n  let link = parseLinkHeader(res.headers.get('Link') || '')\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next)\n    yield res\n    link = parseLinkHeader(res.headers.get('Link') || '')\n  }\n}\n\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath }\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage\nvoid api // eslint-disable-line no-void\n", "import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n", "import { normaliseInput as normaliseInputSingle } from 'ipfs-core-utils/files/normalise-input-single';\nimport { normaliseInput as normaliseInputMultiple } from 'ipfs-core-utils/files/normalise-input-multiple';\nfunction isBytes(obj) {\n    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nfunction isBlob(obj) {\n    return Boolean(obj.constructor) &&\n        (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&\n        typeof obj.stream === 'function';\n}\nfunction isSingle(input) {\n    return typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || '_readableState' in input;\n}\n/**\n * Get a single or multiple normaliser depending on the input.\n */\nexport function getNormaliser(input) {\n    if (isSingle(input)) {\n        return normaliseInputSingle(input);\n    }\n    else {\n        return normaliseInputMultiple(input);\n    }\n}\n", "import { CID } from 'multiformats';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class MemoryBlockStore extends BaseBlockstore {\n    constructor() {\n        super();\n        this.store = new Map();\n    }\n    async *blocks() {\n        for (const [cidStr, bytes] of this.store.entries()) {\n            yield { cid: CID.parse(cidStr), bytes };\n        }\n    }\n    put(cid, bytes) {\n        this.store.set(cid.toString(), bytes);\n        return Promise.resolve();\n    }\n    get(cid) {\n        const bytes = this.store.get(cid.toString());\n        if (!bytes) {\n            throw new Error(`block with cid ${cid.toString()} no found`);\n        }\n        return Promise.resolve(bytes);\n    }\n    has(cid) {\n        return Promise.resolve(this.store.has(cid.toString()));\n    }\n    close() {\n        this.store.clear();\n        return Promise.resolve();\n    }\n}\n", "import { sha256 } from 'multiformats/hashes/sha2';\nexport const unixfsImporterOptionsDefault = {\n    cidVersion: 1,\n    chunker: 'fixed',\n    maxChunkSize: 262144,\n    hasher: sha256,\n    rawLeaves: true,\n    wrapWithDirectory: true,\n    maxChildrenPerNode: 174\n};\n", "const MAX_HEADER_LENGTH = 2000\nconst THROW_ON_MAX_HEADER_LENGTH_EXCEEDED = false\n\nfunction hasRel (x) {\n  return x && x.rel\n}\n\nfunction intoRels (acc, x) {\n  function splitRel (rel) {\n    acc[rel] = Object.assign({}, x, { rel: rel })\n  }\n\n  x.rel.split(/\\s+/).forEach(splitRel)\n\n  return acc\n}\n\nfunction createObjects (acc, p) {\n  // rel=\"next\" => 1: rel 2: next\n  const m = p.match(/\\s*(.+)\\s*=\\s*\"?([^\"]+)\"?/)\n  if (m) acc[m[1]] = m[2]\n  return acc\n}\n\nfunction parseLink (link) {\n  try {\n    const m = link.match(/<?([^>]*)>(.*)/)\n    const linkUrl = m[1]\n    const parts = m[2].split(';')\n    const qry = {}\n    // The origin is unused but it's required to parse relative URLs\n    const url = new URL(linkUrl, 'https://example.com')\n\n    for (const [key, value] of url.searchParams) {\n      qry[key] = value\n    }\n\n    parts.shift()\n\n    let info = parts.reduce(createObjects, {})\n    info = Object.assign({}, qry, info)\n    info.url = linkUrl\n    return info\n  } catch {\n    return null\n  }\n}\n\nfunction checkHeader (linkHeader, options) {\n  if (!linkHeader) return false\n\n  options = options || {}\n  const maxHeaderLength = options.maxHeaderLength || MAX_HEADER_LENGTH\n  const throwOnMaxHeaderLengthExceeded = options.throwOnMaxHeaderLengthExceeded || THROW_ON_MAX_HEADER_LENGTH_EXCEEDED\n\n  if (linkHeader.length > maxHeaderLength) {\n    if (throwOnMaxHeaderLengthExceeded) {\n      throw new Error('Input string too long, it should be under ' + maxHeaderLength + ' characters.')\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nfunction parseLinkHeader (linkHeader, options) {\n  if (!checkHeader(linkHeader, options)) return null\n\n  return linkHeader.split(/,\\s*</)\n    .map(parseLink)\n    .filter(hasRel)\n    .reduce(intoRels, {})\n}\n\nexport { parseLinkHeader }\n", "import toIterable from 'browser-readablestream-to-it';\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { recursive as unixFsExporter } from 'ipfs-unixfs-exporter';\nimport { VerifyingGetOnlyBlockStore } from \"./utils/verifying-get-only-blockstore.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\n// Export unixfs entries from car file\nexport async function* unpack(carReader, roots) {\n    const verifyingBlockService = VerifyingGetOnlyBlockStore.fromCarReader(carReader);\n    if (!roots || roots.length === 0) {\n        roots = await carReader.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockService, { /* options */});\n    }\n}\nexport async function* unpackStream(readable, { roots, blockstore: userBlockstore } = {}) {\n    const carIterator = await CarBlockIterator.fromIterable(asAsyncIterable(readable));\n    const blockstore = userBlockstore || new MemoryBlockStore();\n    for await (const block of carIterator) {\n        await blockstore.put(block.cid, block.bytes);\n    }\n    const verifyingBlockStore = VerifyingGetOnlyBlockStore.fromBlockstore(blockstore);\n    if (!roots || roots.length === 0) {\n        roots = await carIterator.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockStore);\n    }\n}\n/**\n * Upgrade a ReadableStream to an AsyncIterable if it isn't already\n *\n * ReadableStream (e.g res.body) is asyncIterable in node, but not in chrome, yet.\n * see: https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n */\nfunction asAsyncIterable(readable) {\n    // @ts-ignore how to convince tsc that we are checking the type here?\n    return Symbol.asyncIterator in readable ? readable : toIterable(readable);\n}\n", "import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}", "import errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nimport { identity } from 'multiformats/hashes/identity';\nimport dagPbResolver from './unixfs-v1/index.js';\nimport rawResolver from './raw.js';\nimport dagCborResolver from './dag-cbor.js';\nimport identifyResolver from './identity.js';\nconst resolvers = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [identity.code]: identifyResolver\n};\nfunction resolve(cid, name, path, toResolve, depth, blockstore, options) {\n  const resolver = resolvers[cid.code];\n  if (!resolver) {\n    throw errCode(new Error(`No resolver for code ${ cid.code }`), 'ERR_NO_RESOLVER');\n  }\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options);\n}\nexport default resolve;", "import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options);\n  const node = decode(block);\n  let unixfs;\n  let next;\n  if (!name) {\n    name = cid.toString();\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (!path) {\n    path = name;\n  }\n  if (toResolve.length) {\n    let linkCid;\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      linkCid = await findShardCid(node, toResolve[0], blockstore);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    }\n    const nextName = toResolve.shift();\n    const nextPath = `${ path }/${ nextName }`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    };\n  }\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  };\n};\nexport default unixFsResolver;", "import {\n  Bucket,\n  createHAMT\n} from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf)).slice(0, 8).reverse();\n};\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({ hashFn });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n    if (entryName && entryName !== name) {\n      return false;\n    }\n    return true;\n  });\n  if (!link) {\n    return null;\n  }\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\nexport default findShardCid;", "function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length;\n  const blockEnd = blockStart + blockLength;\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    return new Uint8Array(0);\n  }\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    block = block.slice(0, requestedEnd - blockStart);\n  }\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    block = block.slice(requestedStart - blockStart);\n  }\n  return block;\n}\nexport default extractDataFromBlock;", "import errCode from 'err-code';\nconst validateOffsetAndLength = (size, offset, length) => {\n  if (!offset) {\n    offset = 0;\n  }\n  if (offset < 0) {\n    throw errCode(new Error('Offset must be greater than or equal to 0'), 'ERR_INVALID_PARAMS');\n  }\n  if (offset > size) {\n    throw errCode(new Error('Offset must be less than the file size'), 'ERR_INVALID_PARAMS');\n  }\n  if (!length && length !== 0) {\n    length = size - offset;\n  }\n  if (length < 0) {\n    throw errCode(new Error('Length must be greater than or equal to 0'), 'ERR_INVALID_PARAMS');\n  }\n  if (offset + length > size) {\n    length = size - offset;\n  }\n  return {\n    offset,\n    length\n  };\n};\nexport default validateOffsetAndLength;", "import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, { signal: options.signal });\n      let child;\n      switch (childLink.Hash.code) {\n      case dagPb.code:\n        child = await dagPb.decode(block);\n        break;\n      case raw.code:\n        child = block;\n        break;\n      case dagCbor.code:\n        child = await dagCbor.decode(block);\n        break;\n      default:\n        throw Error(`Unsupported codec: ${ childLink.Hash.code }`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {offset, length} = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;", "const directoryContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function* yieldDirectoryContent(options = {}) {\n    const offset = options.offset || 0;\n    const length = options.length || node.Links.length;\n    const links = node.Links.slice(offset, length);\n    for (const link of links) {\n      const result = await resolve(link.Hash, link.Name || '', `${ path }/${ link.Name || '' }`, [], depth + 1, blockstore, options);\n      if (result.entry) {\n        yield result.entry;\n      }\n    }\n  }\n  return yieldDirectoryContent;\n};\nexport default directoryContent;", "import { decode } from '@ipld/dag-pb';\nconst hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent(options = {}) {\n    return listDirectory(node, path, resolve, depth, blockstore, options);\n  }\n  return yieldHamtDirectoryContent;\n};\nasync function* listDirectory(node, path, resolve, depth, blockstore, options) {\n  const links = node.Links;\n  for (const link of links) {\n    const name = link.Name != null ? link.Name.substring(2) : null;\n    if (name) {\n      const result = await resolve(link.Hash, name, `${ path }/${ name }`, [], depth + 1, blockstore, options);\n      yield result.entry;\n    } else {\n      const block = await blockstore.get(link.Hash);\n      node = decode(block);\n      for await (const file of listDirectory(node, path, resolve, depth, blockstore, options)) {\n        yield file;\n      }\n    }\n  }\n}\nexport default hamtShardedDirectoryContent;", "import errCode from 'err-code';\nimport extractDataFromBlock from '../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js';\nconst rawContent = node => {\n  async function* contentGenerator(options = {}) {\n    const {offset, length} = validateOffsetAndLength(node.length, options.offset, options.length);\n    yield extractDataFromBlock(node, 0, offset, offset + length);\n  }\n  return contentGenerator;\n};\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${ path } found in raw node ${ cid }`), 'ERR_NOT_FOUND');\n  }\n  const block = await blockstore.get(cid, options);\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: block.length,\n      node: block\n    }\n  };\n};\nexport default resolve;", "import { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport * as dagCbor from '@ipld/dag-cbor';\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid);\n  const object = dagCbor.decode(block);\n  let subObject = object;\n  let subPath = path;\n  while (toResolve.length) {\n    const prop = toResolve[0];\n    if (prop in subObject) {\n      toResolve.shift();\n      subPath = `${ subPath }/${ prop }`;\n      const subObjectCid = CID.asCID(subObject[prop]);\n      if (subObjectCid) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: block.length,\n            content: async function* () {\n              yield object;\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        };\n      }\n      subObject = subObject[prop];\n    } else {\n      throw errCode(new Error(`No property named ${ prop } found in cbor node ${ cid }`), 'ERR_NO_PROP');\n    }\n  }\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: block.length,\n      content: async function* () {\n        yield object;\n      }\n    }\n  };\n};\nexport default resolve;", "import errCode from 'err-code';\nimport extractDataFromBlock from '../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js';\nimport * as mh from 'multiformats/hashes/digest';\nconst rawContent = node => {\n  async function* contentGenerator(options = {}) {\n    const {offset, length} = validateOffsetAndLength(node.length, options.offset, options.length);\n    yield extractDataFromBlock(node, 0, offset, offset + length);\n  }\n  return contentGenerator;\n};\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${ path } found in raw node ${ cid }`), 'ERR_NOT_FOUND');\n  }\n  const buf = await mh.decode(cid.multihash.bytes);\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: buf.digest.length,\n      node: buf.digest\n    }\n  };\n};\nexport default resolve;", "export function equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "import { equals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class VerifyingGetOnlyBlockStore extends BaseBlockstore {\n    constructor(blockstore) {\n        super();\n        this.store = blockstore;\n    }\n    async get(cid) {\n        const res = await this.store.get(cid);\n        if (!res) {\n            throw new Error(`Incomplete CAR. Block missing for CID ${cid}`);\n        }\n        if (!isValid({ cid, bytes: res })) {\n            throw new Error(`Invalid CAR. Hash of block data does not match CID ${cid}`);\n        }\n        return res;\n    }\n    static fromBlockstore(b) {\n        return new VerifyingGetOnlyBlockStore(b);\n    }\n    static fromCarReader(cr) {\n        return new VerifyingGetOnlyBlockStore({\n            // Return bytes in the same fashion as a Blockstore implementation\n            get: async (cid) => {\n                const block = await cr.get(cid);\n                return block === null || block === void 0 ? void 0 : block.bytes;\n            }\n        });\n    }\n}\nasync function isValid({ cid, bytes }) {\n    const hash = await sha256.digest(bytes);\n    return equals(hash.digest, cid.multihash.digest);\n}\n", "export async function getFilesFromPath() {\n  throw new Error('Unsupported in this environment');\n}\nexport async function* filesFromPath() {\n  throw new Error('Unsupported in this environment');\n}", "// TODO: Use indexedDb\nimport { MemoryBlockStore } from 'ipfs-car/blockstore/memory'\n\nexport const fetch = globalThis.fetch\nexport const Request = globalThis.Request\nexport const Response = globalThis.Response\nexport const Blob = globalThis.Blob\nexport const File = globalThis.File\nexport const Blockstore = MemoryBlockStore\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,qBAAmC;;;AChBnC,qBAAiB;AACjB,qBAAiB;;;ACCjB,iBAAiB,KAAK;AAClB,SAAO,YAAY,OAAO,GAAG,KAAK,eAAe;AACrD;AACA,gBAAgB,KAAK;AACjB,SAAO,QAAQ,IAAI,WAAW,KACzB,KAAI,YAAY,SAAS,UAAU,IAAI,YAAY,SAAS,WAC7D,OAAO,IAAI,WAAW;AAC9B;AACA,kBAAkB,OAAO;AACrB,SAAO,OAAO,UAAU,YAAY,iBAAiB,UAAU,QAAQ,KAAK,KAAK,OAAO,KAAK,KAAK,oBAAoB;AAC1H;AAIO,uBAAuB,OAAO;AACjC,MAAI,SAAS,KAAK,GAAG;AACjB,WAAO,eAAqB,KAAK;AAAA,EACrC,OACK;AACD,WAAO,gBAAuB,KAAK;AAAA,EACvC;AACJ;;;ACvBA;AAEO,qCAA+B,eAAe;AAAA,EACjD,cAAc;AACV,UAAM;AACN,SAAK,QAAQ,oBAAI,IAAI;AAAA,EACzB;AAAA,SACO,SAAS;AACZ,eAAW,CAAC,QAAQ,UAAU,KAAK,MAAM,QAAQ,GAAG;AAChD,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,GAAG,MAAM;AAAA,IAC1C;AAAA,EACJ;AAAA,EACA,IAAI,KAAK,OAAO;AACZ,SAAK,MAAM,IAAI,IAAI,SAAS,GAAG,KAAK;AACpC,WAAO,QAAQ,QAAQ;AAAA,EAC3B;AAAA,EACA,IAAI,KAAK;AACL,UAAM,QAAQ,KAAK,MAAM,IAAI,IAAI,SAAS,CAAC;AAC3C,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,kBAAkB,IAAI,SAAS,YAAY;AAAA,IAC/D;AACA,WAAO,QAAQ,QAAQ,KAAK;AAAA,EAChC;AAAA,EACA,IAAI,KAAK;AACL,WAAO,QAAQ,QAAQ,KAAK,MAAM,IAAI,IAAI,SAAS,CAAC,CAAC;AAAA,EACzD;AAAA,EACA,QAAQ;AACJ,SAAK,MAAM,MAAM;AACjB,WAAO,QAAQ,QAAQ;AAAA,EAC3B;AACJ;;;AC9BA;AACO,IAAM,+BAA+B;AAAA,EACxC,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,cAAc;AAAA,EACd,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,mBAAmB;AAAA,EACnB,oBAAoB;AACxB;;;AHFA,oBAA2B,EAAE,OAAO,YAAY,gBAAgB,QAAQ,cAAc,oBAAoB,mBAAmB,aAAa;AACtI,MAAI,CAAC,SAAU,MAAM,QAAQ,KAAK,KAAK,CAAC,MAAM,QAAS;AACnD,UAAM,IAAI,MAAM,uBAAuB;AAAA,EAC3C;AACA,QAAM,aAAa,iBAAiB,iBAAiB,IAAI,iBAAiB;AAE1E,QAAM,YAAY,MAAM,4BAAK,4BAAK,cAAc,KAAK,GAAG,CAAC,WAAW,SAAS,QAAQ,YAAY,iCAC1F,+BAD0F;AAAA,IAE7F,QAAQ,UAAU,6BAA6B;AAAA,IAC/C,cAAc,gBAAgB,6BAA6B;AAAA,IAC3D,oBAAoB,sBAAsB,6BAA6B;AAAA,IACvE,mBAAmB,sBAAsB,QAAQ,QAAQ,6BAA6B;AAAA,IACtF,WAAW,aAAa,OAAO,6BAA6B,YAAY;AAAA,EAC5E,EAAC,CAAC,CAAC;AACH,MAAI,CAAC,aAAa,CAAC,UAAU,KAAK;AAC9B,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AACA,QAAM,OAAO,UAAU;AACvB,QAAM,EAAE,QAAQ,KAAK,WAAW,MAAM,UAAU,OAAO,CAAC,IAAI,CAAC;AAC7D,QAAM,aAAa,OAAO,OAAO,eAAe;AAChD,MAAI;AACJ,QAAM,WAAW,YAAY;AACzB,qBAAiB,SAAS,WAAW,OAAO,GAAG;AAG3C,YAAM,OAAO,IAAI,KAAK;AAAA,IAC1B;AACA,UAAM,OAAO,MAAM;AACnB,QAAI,CAAC,gBAAgB;AACjB,YAAM,WAAW,MAAM;AAAA,IAC3B;AAAA,EACJ;AACA,QAAM,MAAM;AAAA,KACP,OAAO,iBAAiB;AACrB,UAAI,kBAAkB,MAAM;AACxB,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACrD;AAEA,uBAAiB,SAAS;AAC1B,aAAO;AAAA,cACG,OAAO;AACT,gBAAM,SAAS,MAAM,WAAW,KAAK;AACrC,cAAI,OAAO,MAAM;AACb,kBAAM;AAAA,UACV;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,EAAE,MAAM,IAAI;AACvB;;;AI1DA,IAAM,oBAAoB;AAC1B,IAAM,sCAAsC;AAE5C,gBAAiB,GAAG;AAClB,SAAO,KAAK,EAAE;AAChB;AAEA,kBAAmB,KAAK,GAAG;AACzB,oBAAmB,KAAK;AACtB,QAAI,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,EAAE,IAAS,CAAC;AAAA,EAC9C;AAEA,IAAE,IAAI,MAAM,KAAK,EAAE,QAAQ,QAAQ;AAEnC,SAAO;AACT;AAEA,uBAAwB,KAAK,GAAG;AAE9B,QAAM,IAAI,EAAE,MAAM,2BAA2B;AAC7C,MAAI;AAAG,QAAI,EAAE,MAAM,EAAE;AACrB,SAAO;AACT;AAEA,mBAAoB,MAAM;AACxB,MAAI;AACF,UAAM,IAAI,KAAK,MAAM,gBAAgB;AACrC,UAAM,UAAU,EAAE;AAClB,UAAM,QAAQ,EAAE,GAAG,MAAM,GAAG;AAC5B,UAAM,MAAM,CAAC;AAEb,UAAM,MAAM,IAAI,IAAI,SAAS,qBAAqB;AAElD,eAAW,CAAC,KAAK,UAAU,IAAI,cAAc;AAC3C,UAAI,OAAO;AAAA,IACb;AAEA,UAAM,MAAM;AAEZ,QAAI,OAAO,MAAM,OAAO,eAAe,CAAC,CAAC;AACzC,WAAO,OAAO,OAAO,CAAC,GAAG,KAAK,IAAI;AAClC,SAAK,MAAM;AACX,WAAO;AAAA,EACT,QAAE;AACA,WAAO;AAAA,EACT;AACF;AAEA,qBAAsB,YAAY,SAAS;AACzC,MAAI,CAAC;AAAY,WAAO;AAExB,YAAU,WAAW,CAAC;AACtB,QAAM,kBAAkB,QAAQ,mBAAmB;AACnD,QAAM,iCAAiC,QAAQ,kCAAkC;AAEjF,MAAI,WAAW,SAAS,iBAAiB;AACvC,QAAI,gCAAgC;AAClC,YAAM,IAAI,MAAM,+CAA+C,kBAAkB,cAAc;AAAA,IACjG,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEA,yBAA0B,YAAY,SAAS;AAC7C,MAAI,CAAC,YAAY,YAAY,OAAO;AAAG,WAAO;AAE9C,SAAO,WAAW,MAAM,OAAO,EAC5B,IAAI,SAAS,EACb,OAAO,MAAM,EACb,OAAO,UAAU,CAAC,CAAC;AACxB;;;ACxEA,0CAAuB;;;ACAvB,uBAAoB;AACpB;;;ACDA,uBAAoB;AAGpB;AACA;;;ACJA,uBAAoB;;;ACApB,2BAGO;AAGP,IAAM,SAAS,eAAgB,KAAK;AAClC,SAAQ,OAAM,WAAW,OAAO,GAAG,GAAG,MAAM,GAAG,CAAC,EAAE,QAAQ;AAC5D;AACA,IAAM,uBAAuB,CAAC,OAAO,QAAQ,eAAe;AAC1D,SAAO,QAAQ,IAAI,MAAM,IAAI,UAAQ;AACnC,QAAI,KAAK,QAAQ,MAAM;AACrB,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AACA,QAAI,KAAK,KAAK,WAAW,GAAG;AAC1B,YAAM,MAAM,SAAS,KAAK,MAAM,EAAE;AAClC,aAAO,OAAO,aAAa,KAAK,IAAI,4BAAO;AAAA,QACzC,MAAM,WAAW,SAAS;AAAA,QAC1B,MAAM,WAAW,SAAS;AAAA,MAC5B,GAAG,QAAQ,GAAG,CAAC;AAAA,IACjB;AACA,WAAO,WAAW,IAAI,KAAK,KAAK,UAAU,CAAC,GAAG,IAAI;AAAA,EACpD,CAAC,CAAC;AACJ;AACA,IAAM,WAAW,cAAY;AAC3B,SAAO,SAAS,SAAS,EAAE,EAAE,YAAY,EAAE,SAAS,GAAG,GAAG,EAAE,UAAU,GAAG,CAAC;AAC5E;AACA,IAAM,eAAe,cAAY;AAC/B,MAAI,SAAS,SAAS;AACtB,QAAM,OAAO,CAAC;AACd,SAAO,OAAO,SAAS;AACrB,SAAK,KAAK,MAAM;AAChB,aAAS,OAAO;AAAA,EAClB;AACA,OAAK,KAAK,MAAM;AAChB,SAAO,KAAK,QAAQ;AACtB;AACA,IAAM,eAAe,OAAO,MAAM,MAAM,YAAY,SAAS,YAAY;AACvE,MAAI,CAAC,SAAS;AACZ,UAAM,aAAa,qCAAW,EAAE,OAAO,CAAC;AACxC,cAAU;AAAA,MACR;AAAA,MACA,WAAW;AAAA,MACX,YAAY;AAAA,IACd;AAAA,EACF;AACA,QAAM,qBAAqB,KAAK,OAAO,QAAQ,YAAY,QAAQ,UAAU;AAC7E,QAAM,WAAW,MAAM,QAAQ,WAAW,qBAAqB,IAAI;AACnE,MAAI,SAAS,SAAS,SAAS,GAAG;AAClC,QAAM,aAAa,aAAa,QAAQ;AACxC,MAAI,WAAW,SAAS,QAAQ,WAAW;AACzC,YAAQ,aAAa,WAAW,QAAQ;AACxC,aAAS,SAAS,QAAQ,WAAW,YAAY;AAAA,EACnD;AACA,QAAM,OAAO,KAAK,MAAM,KAAK,WAAQ;AACnC,QAAI,MAAK,QAAQ,MAAM;AACrB,aAAO;AAAA,IACT;AACA,UAAM,cAAc,MAAK,KAAK,UAAU,GAAG,CAAC;AAC5C,UAAM,YAAY,MAAK,KAAK,UAAU,CAAC;AACvC,QAAI,gBAAgB,QAAQ;AAC1B,aAAO;AAAA,IACT;AACA,QAAI,aAAa,cAAc,MAAM;AACnC,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,MAAI,KAAK,QAAQ,QAAQ,KAAK,KAAK,UAAU,CAAC,MAAM,MAAM;AACxD,WAAO,KAAK;AAAA,EACd;AACA,UAAQ;AACR,QAAM,QAAQ,MAAM,WAAW,IAAI,KAAK,MAAM,OAAO;AACrD,SAAO,QAAO,KAAK;AACnB,SAAO,aAAa,MAAM,MAAM,YAAY,SAAS,OAAO;AAC9D;AACA,IAAO,4BAAQ;;;AC/Ef,8BAA8B,OAAO,YAAY,gBAAgB,cAAc;AAC7E,QAAM,cAAc,MAAM;AAC1B,QAAM,WAAW,aAAa;AAC9B,MAAI,kBAAkB,YAAY,eAAe,YAAY;AAC3D,WAAO,IAAI,WAAW,CAAC;AAAA,EACzB;AACA,MAAI,gBAAgB,cAAc,eAAe,UAAU;AACzD,YAAQ,MAAM,MAAM,GAAG,eAAe,UAAU;AAAA,EAClD;AACA,MAAI,kBAAkB,cAAc,iBAAiB,UAAU;AAC7D,YAAQ,MAAM,MAAM,iBAAiB,UAAU;AAAA,EACjD;AACA,SAAO;AACT;AACA,IAAO,kCAAQ;;;ACdf,sBAAoB;AACpB,IAAM,0BAA0B,CAAC,MAAM,QAAQ,WAAW;AACxD,MAAI,CAAC,QAAQ;AACX,aAAS;AAAA,EACX;AACA,MAAI,SAAS,GAAG;AACd,UAAM,6BAAQ,IAAI,MAAM,2CAA2C,GAAG,oBAAoB;AAAA,EAC5F;AACA,MAAI,SAAS,MAAM;AACjB,UAAM,6BAAQ,IAAI,MAAM,wCAAwC,GAAG,oBAAoB;AAAA,EACzF;AACA,MAAI,CAAC,UAAU,WAAW,GAAG;AAC3B,aAAS,OAAO;AAAA,EAClB;AACA,MAAI,SAAS,GAAG;AACd,UAAM,6BAAQ,IAAI,MAAM,2CAA2C,GAAG,oBAAoB;AAAA,EAC5F;AACA,MAAI,SAAS,SAAS,MAAM;AAC1B,aAAS,OAAO;AAAA,EAClB;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AACA,IAAO,qCAAQ;;;ACtBf,uBAAoB;AAGpB;AACA,0BAA0B,YAAY,MAAM,OAAO,KAAK,iBAAiB,GAAG,SAAS;AACnF,MAAI,gBAAgB,YAAY;AAC9B,UAAM,MAAM,gCAAqB,MAAM,gBAAgB,OAAO,GAAG;AACjE,QAAI,IAAI,QAAQ;AACd,YAAM;AAAA,IACR;AACA,sBAAkB,IAAI;AACtB,WAAO;AAAA,EACT;AACA,MAAI,KAAK,QAAQ,MAAM;AACrB,UAAM,8BAAQ,IAAI,MAAM,mBAAmB,GAAG,gBAAgB;AAAA,EAChE;AACA,MAAI;AACJ,MAAI;AACF,WAAO,OAAO,UAAU,KAAK,IAAI;AAAA,EACnC,SAAS,KAAP;AACA,UAAM,8BAAQ,KAAK,gBAAgB;AAAA,EACrC;AACA,MAAI,KAAK,QAAQ,KAAK,KAAK,QAAQ;AACjC,UAAM,MAAM,gCAAqB,KAAK,MAAM,gBAAgB,OAAO,GAAG;AACtE,QAAI,IAAI,QAAQ;AACd,YAAM;AAAA,IACR;AACA,sBAAkB,KAAK,KAAK;AAAA,EAC9B;AACA,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,WAAW,iBAAiB,KAAK,WAAW;AAClD,QAAI,SAAS,cAAc,QAAQ,YAAY,MAAM,cAAc,OAAO,YAAY,QAAQ,cAAc,MAAM,UAAU;AAC1H,YAAM,QAAQ,MAAM,WAAW,IAAI,UAAU,MAAM,EAAE,QAAQ,QAAQ,OAAO,CAAC;AAC7E,UAAI;AACJ,cAAQ,UAAU,KAAK;AAAA,aACZ;AACT,kBAAQ,MAAM,AAAM,QAAO,KAAK;AAChC;AAAA,aACO;AACP,kBAAQ;AACR;AAAA,aACW;AACX,kBAAQ,MAAM,AAAQ,QAAO,KAAK;AAClC;AAAA;AAEA,gBAAM,MAAM,sBAAuB,UAAU,KAAK,MAAO;AAAA;AAE3D,uBAAiB,OAAO,UAAU,YAAY,OAAO,OAAO,KAAK,gBAAgB,OAAO,GAAG;AACzF,0BAAkB,IAAI;AACtB,cAAM;AAAA,MACR;AAAA,IACF;AACA,qBAAiB;AACjB,iBAAa,WAAW;AAAA,EAC1B;AACF;AACA,IAAM,cAAc,CAAC,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,eAAe;AAC3E,4BAA0B,UAAU,CAAC,GAAG;AACtC,UAAM,WAAW,OAAO,SAAS;AACjC,QAAI,aAAa,QAAW;AAC1B,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AACA,UAAM,EAAC,QAAQ,WAAU,mCAAwB,UAAU,QAAQ,QAAQ,QAAQ,MAAM;AACzF,UAAM,QAAQ;AACd,UAAM,MAAM,SAAS;AACrB,WAAO,UAAU,YAAY,MAAM,OAAO,KAAK,GAAG,OAAO;AAAA,EAC3D;AACA,SAAO;AACT;AACA,IAAO,eAAQ;;;AC1Ef,IAAM,mBAAmB,CAAC,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,eAAe;AAChF,wCAAsC,UAAU,CAAC,GAAG;AAClD,UAAM,SAAS,QAAQ,UAAU;AACjC,UAAM,SAAS,QAAQ,UAAU,KAAK,MAAM;AAC5C,UAAM,QAAQ,KAAK,MAAM,MAAM,QAAQ,MAAM;AAC7C,eAAW,QAAQ,OAAO;AACxB,YAAM,SAAS,MAAM,SAAQ,KAAK,MAAM,KAAK,QAAQ,IAAI,GAAI,QAAU,KAAK,QAAQ,MAAO,CAAC,GAAG,QAAQ,GAAG,YAAY,OAAO;AAC7H,UAAI,OAAO,OAAO;AAChB,cAAM,OAAO;AAAA,MACf;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAO,oBAAQ;;;ACbf,IAAM,8BAA8B,CAAC,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,eAAe;AAC3F,qCAAmC,UAAU,CAAC,GAAG;AAC/C,WAAO,cAAc,MAAM,MAAM,UAAS,OAAO,YAAY,OAAO;AAAA,EACtE;AACA,SAAO;AACT;AACA,8BAA8B,MAAM,MAAM,UAAS,OAAO,YAAY,SAAS;AAC7E,QAAM,QAAQ,KAAK;AACnB,aAAW,QAAQ,OAAO;AACxB,UAAM,OAAO,KAAK,QAAQ,OAAO,KAAK,KAAK,UAAU,CAAC,IAAI;AAC1D,QAAI,MAAM;AACR,YAAM,SAAS,MAAM,SAAQ,KAAK,MAAM,MAAM,GAAI,QAAU,QAAS,CAAC,GAAG,QAAQ,GAAG,YAAY,OAAO;AACvG,YAAM,OAAO;AAAA,IACf,OAAO;AACL,YAAM,QAAQ,MAAM,WAAW,IAAI,KAAK,IAAI;AAC5C,aAAO,QAAO,KAAK;AACnB,uBAAiB,QAAQ,cAAc,MAAM,MAAM,UAAS,OAAO,YAAY,OAAO,GAAG;AACvF,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AACA,IAAO,iCAAQ;;;ANhBf,IAAM,cAAc,CAAC,MAAM,SAAS;AAClC,QAAM,OAAO,KAAK,MAAM,KAAK,WAAQ,MAAK,SAAS,IAAI;AACvD,SAAO,QAAQ,KAAK;AACtB;AACA,IAAM,mBAAmB;AAAA,EACvB,KAAK;AAAA,EACL,MAAM;AAAA,EACN,WAAW;AAAA,EACX,0BAA0B;AAAA,EAC1B,UAAU,CAAC,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,eAAe;AACjE,WAAO,MAAM,CAAC;AAAA,EAChB;AAAA,EACA,SAAS,CAAC,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,eAAe;AAChE,WAAO,MAAM,CAAC;AAAA,EAChB;AACF;AACA,IAAM,iBAAiB,OAAO,KAAK,MAAM,MAAM,WAAW,UAAS,OAAO,YAAY,YAAY;AAChG,QAAM,QAAQ,MAAM,WAAW,IAAI,KAAK,OAAO;AAC/C,QAAM,OAAO,QAAO,KAAK;AACzB,MAAI;AACJ,MAAI;AACJ,MAAI,CAAC,MAAM;AACT,WAAO,IAAI,SAAS;AAAA,EACtB;AACA,MAAI,KAAK,QAAQ,MAAM;AACrB,UAAM,8BAAQ,IAAI,MAAM,mBAAmB,GAAG,gBAAgB;AAAA,EAChE;AACA,MAAI;AACF,aAAS,OAAO,UAAU,KAAK,IAAI;AAAA,EACrC,SAAS,KAAP;AACA,UAAM,8BAAQ,KAAK,gBAAgB;AAAA,EACrC;AACA,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,MAAI,UAAU,QAAQ;AACpB,QAAI;AACJ,QAAI,UAAU,OAAO,SAAS,0BAA0B;AACtD,gBAAU,MAAM,0BAAa,MAAM,UAAU,IAAI,UAAU;AAAA,IAC7D,OAAO;AACL,gBAAU,YAAY,MAAM,UAAU,EAAE;AAAA,IAC1C;AACA,QAAI,CAAC,SAAS;AACZ,YAAM,8BAAQ,IAAI,MAAM,qBAAqB,GAAG,eAAe;AAAA,IACjE;AACA,UAAM,WAAW,UAAU,MAAM;AACjC,UAAM,WAAW,GAAI,QAAU;AAC/B,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,MAAM,YAAY;AAAA,MAClB,MAAM;AAAA,IACR;AAAA,EACF;AACA,SAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM,OAAO,YAAY,IAAI,cAAc;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,iBAAiB,OAAO,MAAM,KAAK,MAAM,QAAQ,MAAM,UAAS,OAAO,UAAU;AAAA,MAC1F;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,OAAO,SAAS;AAAA,IACxB;AAAA,IACA;AAAA,EACF;AACF;AACA,IAAO,oBAAQ;;;AO5Ef,uBAAoB;AAGpB,IAAM,aAAa,UAAQ;AACzB,mCAAiC,UAAU,CAAC,GAAG;AAC7C,UAAM,EAAC,QAAQ,WAAU,mCAAwB,KAAK,QAAQ,QAAQ,QAAQ,QAAQ,MAAM;AAC5F,UAAM,gCAAqB,MAAM,GAAG,QAAQ,SAAS,MAAM;AAAA,EAC7D;AACA,SAAO;AACT;AACA,IAAM,UAAU,OAAO,KAAK,MAAM,MAAM,WAAW,UAAS,OAAO,YAAY,YAAY;AACzF,MAAI,UAAU,QAAQ;AACpB,UAAM,8BAAQ,IAAI,MAAM,iBAAkB,0BAA4B,KAAM,GAAG,eAAe;AAAA,EAChG;AACA,QAAM,QAAQ,MAAM,WAAW,IAAI,KAAK,OAAO;AAC/C,SAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,WAAW,KAAK;AAAA,MACzB;AAAA,MACA,MAAM,MAAM;AAAA,MACZ,MAAM;AAAA,IACR;AAAA,EACF;AACF;AACA,IAAO,cAAQ;;;AC5Bf;AACA,uBAAoB;AAEpB,IAAM,WAAU,OAAO,KAAK,MAAM,MAAM,WAAW,UAAS,OAAO,YAAY,YAAY;AACzF,QAAM,QAAQ,MAAM,WAAW,IAAI,GAAG;AACtC,QAAM,SAAS,AAAQ,QAAO,KAAK;AACnC,MAAI,YAAY;AAChB,MAAI,UAAU;AACd,SAAO,UAAU,QAAQ;AACvB,UAAM,OAAO,UAAU;AACvB,QAAI,QAAQ,WAAW;AACrB,gBAAU,MAAM;AAChB,gBAAU,GAAI,WAAa;AAC3B,YAAM,eAAe,IAAI,MAAM,UAAU,KAAK;AAC9C,UAAI,cAAc;AAChB,eAAO;AAAA,UACL,OAAO;AAAA,YACL,MAAM;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA,MAAM;AAAA,YACN;AAAA,YACA,MAAM,MAAM;AAAA,YACZ,SAAS,mBAAmB;AAC1B,oBAAM;AAAA,YACR;AAAA,UACF;AAAA,UACA,MAAM;AAAA,YACJ,KAAK;AAAA,YACL,MAAM;AAAA,YACN,MAAM;AAAA,YACN;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,kBAAY,UAAU;AAAA,IACxB,OAAO;AACL,YAAM,8BAAQ,IAAI,MAAM,qBAAsB,2BAA6B,KAAM,GAAG,aAAa;AAAA,IACnG;AAAA,EACF;AACA,SAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA,MAAM,MAAM;AAAA,MACZ,SAAS,mBAAmB;AAC1B,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AACA,IAAO,mBAAQ;;;ACxDf,uBAAoB;AAGpB;AACA,IAAM,cAAa,UAAQ;AACzB,mCAAiC,UAAU,CAAC,GAAG;AAC7C,UAAM,EAAC,QAAQ,WAAU,mCAAwB,KAAK,QAAQ,QAAQ,QAAQ,QAAQ,MAAM;AAC5F,UAAM,gCAAqB,MAAM,GAAG,QAAQ,SAAS,MAAM;AAAA,EAC7D;AACA,SAAO;AACT;AACA,IAAM,WAAU,OAAO,KAAK,MAAM,MAAM,WAAW,UAAS,OAAO,YAAY,YAAY;AACzF,MAAI,UAAU,QAAQ;AACpB,UAAM,8BAAQ,IAAI,MAAM,iBAAkB,0BAA4B,KAAM,GAAG,eAAe;AAAA,EAChG;AACA,QAAM,MAAM,MAAM,AAAG,OAAO,IAAI,UAAU,KAAK;AAC/C,SAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,YAAW,IAAI,MAAM;AAAA,MAC9B;AAAA,MACA,MAAM,IAAI,OAAO;AAAA,MACjB,MAAM,IAAI;AAAA,IACZ;AAAA,EACF;AACF;AACA,IAAO,mBAAQ;;;AVpBf,IAAM,YAAY;AAAA,GACT,QAAO;AAAA,GACT,QAAO;AAAA,GACH,OAAO;AAAA,GACf,SAAS,OAAO;AACnB;AACA,kBAAiB,KAAK,MAAM,MAAM,WAAW,OAAO,YAAY,SAAS;AACvE,QAAM,WAAW,UAAU,IAAI;AAC/B,MAAI,CAAC,UAAU;AACb,UAAM,8BAAQ,IAAI,MAAM,wBAAyB,IAAI,MAAO,GAAG,iBAAiB;AAAA,EAClF;AACA,SAAO,SAAS,KAAK,MAAM,MAAM,WAAW,UAAS,OAAO,YAAY,OAAO;AACjF;AACA,IAAO,oBAAQ;;;ADnBf,sBAAiB;AACjB,IAAM,mBAAmB,CAAC,OAAO,OAAO;AACtC,SAAQ,MAAK,KAAK,EAAE,MAAM,kBAAkB,KAAK,CAAC,GAAG,OAAO,OAAO;AACrE;AACA,IAAM,aAAa,UAAQ;AACzB,MAAI,gBAAgB,YAAY;AAC9B,WAAO;AAAA,MACL,KAAK,IAAI,OAAO,IAAI;AAAA,MACpB,WAAW,CAAC;AAAA,IACd;AAAA,EACF;AACA,QAAM,MAAM,IAAI,MAAM,IAAI;AAC1B,MAAI,KAAK;AACP,WAAO;AAAA,MACL;AAAA,MACA,WAAW,CAAC;AAAA,IACd;AAAA,EACF;AACA,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI,KAAK,QAAQ,QAAQ,MAAM,GAAG;AAChC,aAAO,KAAK,UAAU,CAAC;AAAA,IACzB;AACA,UAAM,SAAS,iBAAiB,IAAI;AACpC,WAAO;AAAA,MACL,KAAK,IAAI,MAAM,OAAO,EAAE;AAAA,MACxB,WAAW,OAAO,MAAM,CAAC;AAAA,IAC3B;AAAA,EACF;AACA,QAAM,8BAAQ,IAAI,MAAM,qBAAsB,MAAO,GAAG,cAAc;AACxE;AACA,yBAAgC,MAAM,YAAY,UAAU,CAAC,GAAG;AAC9D,MAAI,EAAC,KAAK,cAAa,WAAW,IAAI;AACtC,MAAI,OAAO,IAAI,SAAS;AACxB,MAAI,YAAY;AAChB,QAAM,gBAAgB,UAAU;AAChC,SAAO,MAAM;AACX,UAAM,SAAS,MAAM,kBAAQ,KAAK,MAAM,WAAW,WAAW,eAAe,YAAY,OAAO;AAChG,QAAI,CAAC,OAAO,SAAS,CAAC,OAAO,MAAM;AACjC,YAAM,8BAAQ,IAAI,MAAM,qBAAsB,MAAO,GAAG,eAAe;AAAA,IACzE;AACA,QAAI,OAAO,OAAO;AAChB,YAAM,OAAO;AAAA,IACf;AACA,QAAI,CAAC,OAAO,MAAM;AAChB;AAAA,IACF;AACA,gBAAY,OAAO,KAAK;AACxB,UAAM,OAAO,KAAK;AAClB,WAAO,OAAO,KAAK;AACnB,gBAAY,OAAO,KAAK;AAAA,EAC1B;AACF;AACA,wBAA+B,MAAM,YAAY,UAAU,CAAC,GAAG;AAC7D,QAAM,SAAS,MAAM,6BAAK,SAAS,MAAM,YAAY,OAAO,CAAC;AAC7D,MAAI,CAAC,QAAQ;AACX,UAAM,8BAAQ,IAAI,MAAM,qBAAsB,MAAO,GAAG,eAAe;AAAA,EACzE;AACA,SAAO;AACT;AACA,0BAAiC,MAAM,YAAY,UAAU,CAAC,GAAG;AAC/D,QAAM,OAAO,MAAM,SAAS,MAAM,YAAY,OAAO;AACrD,MAAI,CAAC,MAAM;AACT;AAAA,EACF;AACA,QAAM;AACN,MAAI,KAAK,SAAS,aAAa;AAC7B,qBAAiB,SAAS,QAAQ,MAAM,OAAO,GAAG;AAChD,YAAM;AAAA,IACR;AAAA,EACF;AACA,0BAAwB,OAAM,UAAS;AACrC,qBAAiB,QAAQ,MAAK,QAAQ,QAAO,GAAG;AAC9C,YAAM;AACN,UAAI,gBAAgB,YAAY;AAC9B;AAAA,MACF;AACA,UAAI,KAAK,SAAS,aAAa;AAC7B,eAAO,QAAQ,MAAM,QAAO;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AACF;;;AYpFO,gBAAgB,GAAG,GAAG;AAC3B,MAAI,MAAM,GAAG;AACX,WAAO;AAAA,EACT;AACA,MAAI,EAAE,eAAe,EAAE,YAAY;AACjC,WAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,IAAI,EAAE,YAAY,KAAK;AACrC,QAAI,EAAE,OAAO,EAAE,IAAI;AACjB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;ACZA;AAEO,+CAAyC,eAAe;AAAA,EAC3D,YAAY,YAAY;AACpB,UAAM;AACN,SAAK,QAAQ;AAAA,EACjB;AAAA,QACM,IAAI,KAAK;AACX,UAAM,MAAM,MAAM,KAAK,MAAM,IAAI,GAAG;AACpC,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,yCAAyC,KAAK;AAAA,IAClE;AACA,QAAI,CAAC,QAAQ,EAAE,KAAK,OAAO,IAAI,CAAC,GAAG;AAC/B,YAAM,IAAI,MAAM,sDAAsD,KAAK;AAAA,IAC/E;AACA,WAAO;AAAA,EACX;AAAA,SACO,eAAe,GAAG;AACrB,WAAO,IAAI,2BAA2B,CAAC;AAAA,EAC3C;AAAA,SACO,cAAc,IAAI;AACrB,WAAO,IAAI,2BAA2B;AAAA,MAElC,KAAK,OAAO,QAAQ;AAChB,cAAM,QAAQ,MAAM,GAAG,IAAI,GAAG;AAC9B,eAAO,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM;AAAA,MAC/D;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AACA,uBAAuB,EAAE,KAAK,SAAS;AACnC,QAAM,OAAO,MAAM,OAAO,OAAO,KAAK;AACtC,SAAO,OAAO,KAAK,QAAQ,IAAI,UAAU,MAAM;AACnD;;;AdnBA,6BAAoC,UAAU,EAAE,OAAO,YAAY,mBAAmB,CAAC,GAAG;AACtF,QAAM,cAAc,MAAM,iBAAiB,aAAa,gBAAgB,QAAQ,CAAC;AACjF,QAAM,aAAa,kBAAkB,IAAI,iBAAiB;AAC1D,mBAAiB,SAAS,aAAa;AACnC,UAAM,WAAW,IAAI,MAAM,KAAK,MAAM,KAAK;AAAA,EAC/C;AACA,QAAM,sBAAsB,2BAA2B,eAAe,UAAU;AAChF,MAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAC9B,YAAQ,MAAM,YAAY,SAAS;AAAA,EACvC;AACA,aAAW,QAAQ,OAAO;AACtB,WAAO,UAAe,MAAM,mBAAmB;AAAA,EACnD;AACJ;AAOA,yBAAyB,UAAU;AAE/B,SAAO,OAAO,iBAAiB,WAAW,WAAW,iDAAW,QAAQ;AAC5E;;;AetCA,kCAAyC;AACvC,QAAM,IAAI,MAAM,iCAAiC;AACnD;AACA,gCAAuC;AACrC,QAAM,IAAI,MAAM,iCAAiC;AACnD;;;ArBkBA,6BAA2B;;;AsBpBpB,IAAM,QAAQ,WAAW;AACzB,IAAM,UAAU,WAAW;AAC3B,IAAM,WAAW,WAAW;AAC5B,IAAM,OAAO,WAAW;AACxB,IAAM,OAAO,WAAW;AACxB,IAAM,aAAa;;;AtBuB1B,IAAM,kBAAkB;AACxB,IAAM,yBAAyB;AAC/B,IAAM,qBAAqB,OAAO,OAAO;AACzC,IAAM,iBAAiB;AACvB,IAAM,iBAAiB;AAEvB,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB,KAAK;AAuBxB,6BAA8B;AACnC,QAAM,WAAW,oCAAe,qBAAqB,iBAAiB;AACtE,SAAO,MAAM,SAAS,MAAM;AAAA,EAAC,CAAC;AAChC;AAOA,IAAM,oBAAoB,kBAAkB;AAK5C,wBAAkB;AAAA,EAahB,YAAa;AAAA,IACX;AAAA,IACA,WAAW,IAAI,IAAI,0BAA0B;AAAA,IAC7C;AAAA,IACA,gBAAQ;AAAA,KACP;AAMD,SAAK,QAAQ;AAKb,SAAK,WAAW;AAIhB,SAAK,cAAc,eAAe,kBAAkB;AAKpD,SAAK,QAAQ;AAAA,EACf;AAAA,SAOO,QAAS,OAAO;AACrB,QAAI,CAAC;AAAO,YAAM,IAAI,MAAM,eAAe;AAC3C,WAAO;AAAA,MACL,eAAe,UAAU;AAAA,MACzB,YAAY;AAAA,IACd;AAAA,EACF;AAAA,eAQa,IAAK,EAAE,UAAU,OAAO,cAAc,mBAAmB,gBAAQ,SAAU,OAAO;AAAA,IAC7F;AAAA,IACA;AAAA,IACA,aAAa;AAAA,IACb,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB;AAAA,IACA;AAAA,MACE,CAAC,GAAG;AACN,QAAI,gBAAgB,kBAAkB,eAAe,gBAAgB;AACnE,YAAM,IAAI,MAAM,8EAA8E;AAAA,IAChG;AACA,UAAM,aAAa,IAAI,WAAW;AAClC,QAAI;AACF,YAAM,EAAE,KAAK,SAAS,MAAM,KAAK;AAAA,QAC/B,OAAO,MAAM,KAAK,KAAK,EAAE,IAAI,iBAAiB;AAAA,QAC9C;AAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd,oBAAoB;AAAA,MACtB,CAAC;AACD,wBAAkB,eAAe,KAAK,SAAS,CAAC;AAChD,YAAM,MAAM,MAAM,UAAU,aAAa,GAAG;AAC5C,aAAO,MAAM,YAAY,OAAO,EAAE,UAAU,OAAO,aAAa,cAAM,GAAG,KAAK,EAAE,eAAe,YAAY,cAAc,MAAM,OAAO,CAAC;AAAA,IACzI,UAAE;AACA,YAAM,WAAW,MAAM;AAAA,IACzB;AAAA,EACF;AAAA,eAQa,OAAQ,EAAE,UAAU,OAAO,cAAc,mBAAmB,gBAAQ,SAAU,KAAK;AAAA,IAC9F;AAAA,IACA;AAAA,IACA,aAAa;AAAA,IACb,eAAe;AAAA,IACf;AAAA,IACA;AAAA,MACE,CAAC,GAAG;AACN,QAAI,gBAAgB,kBAAkB,eAAe,gBAAgB;AACnE,YAAM,IAAI,MAAM,8EAA8E;AAAA,IAChG;AACA,UAAM,aAAa;AACnB,UAAM,MAAM,IAAI,IAAI,OAAO,QAAQ;AACnC,QAAI,UAAU,YAAY,QAAQ,KAAK;AAEvC,QAAI,MAAM;AACR,gBAAU,iCAAK,UAAL,EAAc,UAAU,mBAAmB,IAAI,EAAE;AAAA,IAC7D;AAEA,UAAM,QAAQ,MAAM,IAAI,SAAS;AACjC,QAAI,MAAM,MAAM,MAAM;AACpB,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,QAAI,MAAM,SAAS,GAAG;AACpB,YAAM,IAAI,MAAM,gBAAgB;AAAA,IAClC;AAEA,UAAM,UAAU,MAAM,GAAG,SAAS;AAClC,UAAM,WAAW,IAAI,oBAAoB,KAAK,YAAY,EAAE,SAAS,CAAC;AAMtE,UAAM,aAAa,OAAM,SAAO;AAC9B,YAAM,WAAW,CAAC;AAClB,uBAAiB,QAAQ,MAAK;AAC5B,iBAAS,KAAK,IAAI;AAAA,MACpB;AAEA,YAAM,UAAU,IAAI,KAAK,UAAU,EAAE,MAAM,2BAA2B,CAAC;AACvE,YAAM,MAAM,MAAM,4BAChB,YAAY;AACV,cAAM,YAAY;AAElB,YAAI;AACJ,YAAI;AACF,qBAAW,MAAM,OAAM,IAAI,SAAS,GAAG;AAAA,YACrC,QAAQ;AAAA,YACR;AAAA,YACA,MAAM;AAAA,YACN;AAAA,UACF,CAAC;AAAA,QACH,SAA2B,KAAzB;AACA,gBAAM,UAAU,OAAO,UAAU,IAAI,0BAAW,GAAG,IAAI;AAAA,QACzD;AAEA,YAAI,SAAS,WAAW,KAAK;AAC3B,gBAAM,IAAI,MAAM,cAAc;AAAA,QAChC;AACA,cAAM,OAAM,MAAM,SAAS,KAAK;AAChC,YAAI,CAAC,SAAS,IAAI;AAChB,gBAAM,IAAI,MAAM,KAAI,OAAO;AAAA,QAC7B;AAEA,YAAI,KAAI,QAAQ,SAAS;AACvB,gBAAM,IAAI,MAAM,gCAAgC,sBAAsB,KAAI,KAAK;AAAA,QACjF;AACA,eAAO,KAAI;AAAA,MACb,GACA,EAAE,SAAS,WAAW,CACxB;AAEA,uBAAiB,cAAc,QAAQ,IAAI;AAC3C,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,UAAU,wBAAwB,UAAU;AAC3D,qBAAiB,KAAK,OAAO,SAAS,KAAK,CAAC,GAAG;AAAA,IAAC;AAChD,WAAO;AAAA,EACT;AAAA,eAQa,IAAK,EAAE,UAAU,OAAO,cAAc,mBAAmB,gBAAQ,SAAU,KAAK,UAAU,CAAC,GAAG;AACzG,UAAM,MAAM,IAAI,IAAI,OAAO,OAAO,QAAQ;AAC1C,UAAM,YAAY;AAClB,UAAM,MAAM,MAAM,OAAM,IAAI,SAAS,GAAG;AAAA,MACtC,QAAQ;AAAA,MACR,SAAS,YAAY,QAAQ,KAAK;AAAA,MAClC,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,IAAI,MAAM,cAAc;AAAA,IAChC;AACA,WAAO,eAAe,GAAG;AAAA,EAC3B;AAAA,eASa,OAAQ,EAAE,UAAU,OAAO,cAAc,qBAAqB,KAAK,UAAU,CAAC,GAAG;AAC5F,YAAQ,IAAI,gBAAgB,KAAK,UAAU,OAAO,aAAa,OAAO;AACtE,UAAM,MAAM,6BAA6B;AAAA,EAC3C;AAAA,eAQa,OAAQ,EAAE,UAAU,OAAO,cAAc,mBAAmB,gBAAQ,SAAU,KAAK,UAAU,CAAC,GAAG;AAC5G,UAAM,MAAM,IAAI,IAAI,UAAU,OAAO,QAAQ;AAC7C,UAAM,YAAY;AAClB,UAAM,MAAM,MAAM,OAAM,IAAI,SAAS,GAAG;AAAA,MACtC,QAAQ;AAAA,MACR,SAAS,YAAY,QAAQ,KAAK;AAAA,MAClC,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,IAAI,MAAM,cAAc;AAAA,IAChC;AACA,QAAI,IAAI,WAAW,KAAK;AACtB,aAAO;AAAA,IACT;AACA,QAAI,CAAC,IAAI,IAAI;AACX,YAAM,IAAI,MAAM,IAAI,UAAU;AAAA,IAChC;AACA,WAAO,IAAI,KAAK;AAAA,EAClB;AAAA,gBAOe,KAAM,SAAS,EAAE,SAAS,IAAI,KAAK,EAAE,YAAY,GAAG,aAAa,UAAU,WAAW,CAAC,GAAG;AAMvG,4BAAyB,EAAE,UAAU,OAAO,cAAc,mBAAmB,gBAAQ,SAAU,EAAE,iBAAQ,eAAQ;AAC/G,YAAM,SAAS,IAAI,gBAAgB,EAAE,iBAAQ,MAAM,MAAK,SAAS,EAAE,CAAC;AACpE,YAAM,MAAM,IAAI,IAAI,gBAAgB,UAAU,QAAQ;AACtD,YAAM,YAAY;AAClB,aAAO,OAAM,IAAI,SAAS,GAAG;AAAA,QAC3B,QAAQ;AAAA,QACR,SAAS,iCACJ,YAAY,QAAQ,KAAK,IADrB;AAAA,UAEP,kCAAkC;AAAA,QACpC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI,QAAQ;AACZ,UAAM,OAAO,aAAa,MAAM,MAAM;AACtC,qBAAiB,OAAO,UAAU,UAAU,SAAS,EAAE,QAAQ,KAAK,CAAC,GAAG;AACtE,UAAI,CAAC,IAAI,IAAI;AAEX,YAAI,IAAI,WAAW,KAAK;AACtB,gBAAM,IAAI,MAAM,cAAc;AAAA,QAChC;AAGA,cAAM,eAAe,MAAM,IAAI,KAAK;AACpC,cAAM,IAAI,MAAM,GAAG,IAAI,UAAU,IAAI,cAAc,eAAe,OAAO,aAAa,UAAU,IAAI;AAAA,MACtG;AACA,YAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,iBAAW,UAAU,MAAM;AACzB,YAAI,EAAE,QAAQ,YAAY;AACxB;AAAA,QACF;AACA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAmBA,IAAK,OAAO,SAAS;AACnB,WAAO,YAAY,IAAI,MAAM,OAAO,OAAO;AAAA,EAC7C;AAAA,EA2CA,OAAQ,KAAK,SAAS;AACpB,WAAO,YAAY,OAAO,MAAM,KAAK,OAAO;AAAA,EAC9C;AAAA,EAOA,IAAK,KAAK,SAAS;AACjB,WAAO,YAAY,IAAI,MAAM,KAAK,OAAO;AAAA,EAC3C;AAAA,EAOA,OAAQ,KAAK,SAAS;AACpB,WAAO,YAAY,OAAO,MAAM,KAAK,OAAO;AAAA,EAC9C;AAAA,EAOA,OAAQ,KAAK,SAAS;AACpB,WAAO,YAAY,OAAO,MAAM,KAAK,OAAO;AAAA,EAC9C;AAAA,EAgBA,KAAM,MAAM;AACV,WAAO,YAAY,KAAK,MAAM,IAAI;AAAA,EACpC;AACF;AAQA,0BAA2B,EAAE,SAAS,MAAM,OAAO;AACjD,QAAM,SAAS,CAAC;AAChB,mBAAiB,SAAS,QAAQ,GAAG;AACnC,WAAO,KAAK,KAAK;AAAA,EACnB;AACA,QAAM,OAAO,IAAI,KAAK,QAAQ,mBAAmB,IAAI,CAAC;AACtD,SAAO,OAAO,OAAO,MAAM,EAAE,KAAK,IAAI,SAAS,EAAE,CAAC;AACpD;AAUA,4BAA6B,YAAY;AACvC,QAAM,aAAa,WAAW,QAAQ,GAAG;AACzC,SAAO,eAAe,KAAK,aAAa,WAAW,UAAU,aAAa,CAAC;AAC7E;AAOA,wBAAyB,KAAK;AAC5B,QAAM,WAAW,OAAO,OAAO,KAAK;AAAA,IAClC,gBAAgB,mBAAoB;AAClC,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,IAAI,MAAM,wBAAwB,IAAI,UAAU,IAAI,8FAA8F;AAAA,MAC1J;AAEA,UAAI,CAAC,IAAI,MAAM;AACb,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AACA,YAAM,aAAa,IAAI,WAAW;AAClC,UAAI;AACF,yBAAiB,SAAS,aAAa,IAAI,MAAM,EAAE,WAAW,CAAC,GAAG;AAChE,gBAAM;AAAA,QACR;AAAA,MACF,UAAE;AACA,cAAM,WAAW,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,IACA,OAAO,YAAY;AACjB,UAAI,CAAC,IAAI,IAAI;AACX,cAAM,IAAI,MAAM,wBAAwB,IAAI,UAAU,IAAI,qFAAqF;AAAA,MACjJ;AACA,YAAM,QAAQ,CAAC;AAEf,uBAAiB,SAAS,SAAS,eAAe,GAAG;AACnD,YAAI,MAAM,SAAS,aAAa;AAC9B;AAAA,QACF;AACA,cAAM,OAAO,MAAM,WAAW,KAAK;AACnC,cAAM,KAAK,IAAI;AAAA,MACjB;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACD,SAAO;AACT;AASA,2BAA4B,MAAM;AAEhC,MAAI;AACJ,SAAO;AAAA,IACL,MAAM,KAAK;AAAA,QACP,UAAW;AACb,eAAS,UAAU,KAAK,OAAO;AAC/B,aAAO;AAAA,IACT;AAAA,EACF;AACF;AASA,0BAA4B,IAAI,SAAS,MAAM;AAC7C,MAAI,MAAM,MAAM,GAAG,SAAS,IAAI;AAChC,QAAM;AACN,MAAI,OAAO,gBAAgB,IAAI,QAAQ,IAAI,MAAM,KAAK,EAAE;AAExD,SAAO,QAAQ,KAAK,MAAM;AAExB,UAAM,MAAM,GAAG,SAAS,KAAK,IAAI;AACjC,UAAM;AACN,WAAO,gBAAgB,IAAI,QAAQ,IAAI,MAAM,KAAK,EAAE;AAAA,EACtD;AACF;",
  "names": []
}
