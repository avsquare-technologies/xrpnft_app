{
  "version": 3,
  "sources": ["../nft.storage/src/lib.js", "../nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js", "../nft.storage/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js", "../nft.storage/node_modules/ipfs-car/dist/esm/blockstore/memory.js", "../nft.storage/node_modules/ipfs-car/dist/esm/pack/constants.js", "../nft.storage/src/token.js", "../nft.storage/node_modules/@ipld/dag-cbor/esm/index.js", "../nft.storage/src/platform.web.js", "../nft.storage/src/gateway.js", "../nft.storage/src/bs-car-reader.js"],
  "sourcesContent": ["/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport throttledQueue from 'throttled-queue'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\nimport pipe from 'it-pipe'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = NFTStorage.auth(token)\n    const targetSize = MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, { type: 'application/car' })\n        const cid = await pRetry(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await fetch(url.toString(), {\n                method: 'POST',\n                headers,\n                body: carFile,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return Token.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = pipe(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore()\n  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory })\n  const car = new BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token }\n", "import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n", "import { normaliseInput as normaliseInputSingle } from 'ipfs-core-utils/files/normalise-input-single';\nimport { normaliseInput as normaliseInputMultiple } from 'ipfs-core-utils/files/normalise-input-multiple';\nfunction isBytes(obj) {\n    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nfunction isBlob(obj) {\n    return Boolean(obj.constructor) &&\n        (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&\n        typeof obj.stream === 'function';\n}\nfunction isSingle(input) {\n    return typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || '_readableState' in input;\n}\n/**\n * Get a single or multiple normaliser depending on the input.\n */\nexport function getNormaliser(input) {\n    if (isSingle(input)) {\n        return normaliseInputSingle(input);\n    }\n    else {\n        return normaliseInputMultiple(input);\n    }\n}\n", "import { CID } from 'multiformats';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class MemoryBlockStore extends BaseBlockstore {\n    constructor() {\n        super();\n        this.store = new Map();\n    }\n    async *blocks() {\n        for (const [cidStr, bytes] of this.store.entries()) {\n            yield { cid: CID.parse(cidStr), bytes };\n        }\n    }\n    put(cid, bytes) {\n        this.store.set(cid.toString(), bytes);\n        return Promise.resolve();\n    }\n    get(cid) {\n        const bytes = this.store.get(cid.toString());\n        if (!bytes) {\n            throw new Error(`block with cid ${cid.toString()} no found`);\n        }\n        return Promise.resolve(bytes);\n    }\n    has(cid) {\n        return Promise.resolve(this.store.has(cid.toString()));\n    }\n    close() {\n        this.store.clear();\n        return Promise.resolve();\n    }\n}\n", "import { sha256 } from 'multiformats/hashes/sha2';\nexport const unixfsImporterOptionsDefault = {\n    cidVersion: 1,\n    chunker: 'fixed',\n    maxChunkSize: 262144,\n    hasher: sha256,\n    rawLeaves: true,\n    wrapWithDirectory: true,\n    maxChildrenPerNode: 174\n};\n", "import { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Block from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      const content = blob.stream()\n      const { root: cid } = await pack({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await pack({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: dagCbor,\n      hasher: sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n", "import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);", "import { MemoryBlockStore } from 'ipfs-car/blockstore/memory'\n\nexport const fetch = globalThis.fetch\nexport const FormData = globalThis.FormData\nexport const Headers = globalThis.Headers\nexport const Request = globalThis.Request\nexport const Response = globalThis.Response\nexport const Blob = globalThis.Blob\nexport const File = globalThis.File\nexport const ReadableStream = globalThis.ReadableStream\nexport const Blockstore = MemoryBlockStore\n", "export const GATEWAY = new URL('https://nftstorage.link/')\n\n/**\n * @typedef {string|URL} GatewayURL Base URL of an IPFS Gateway e.g. https://dweb.link/ or https://ipfs.io/\n * @typedef {{ gateway?: GatewayURL }} GatewayURLOptions\n */\n\n/**\n * Convert an IPFS URL (starting ipfs://) to a gateway URL (starting https://)\n * that can be used in a webpage. If the passed URL is not an IPFS URL it is\n * returned as a new URL object with no further changes.\n *\n * @param {string|URL} url An IPFS URL e.g. ipfs://bafy.../path\n * @param {GatewayURLOptions} [options] Options that allow customization of the gateway used.\n * @returns {URL} An IPFS gateway URL e.g. https://nftstorage.link/ipfs/bafy.../path\n */\nexport const toGatewayURL = (url, options = {}) => {\n  const gateway = options.gateway || GATEWAY\n  url = new URL(String(url))\n  return url.protocol === 'ipfs:'\n    ? new URL(`/ipfs/${url.href.slice('ipfs://'.length)}`, gateway)\n    : url\n}\n", "/**\n * An implementation of the CAR reader interface that is backed by a blockstore.\n *\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@ipld/car/api').CarReader} CarReader\n * @implements {CarReader}\n */\nexport class BlockstoreCarReader {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {import('ipfs-car/blockstore').Blockstore} blockstore\n   */\n  constructor(version, roots, blockstore) {\n    /**\n     * @private\n     */\n    this._version = version\n    /**\n     * @private\n     */\n    this._roots = roots\n    /**\n     * @private\n     */\n    this._blockstore = blockstore\n  }\n\n  get version() {\n    return this._version\n  }\n\n  get blockstore() {\n    return this._blockstore\n  }\n\n  async getRoots() {\n    return this._roots\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  has(cid) {\n    return this._blockstore.has(cid)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  async get(cid) {\n    const bytes = await this._blockstore.get(cid)\n    return { cid, bytes }\n  }\n\n  blocks() {\n    return this._blockstore.blocks()\n  }\n\n  async *cids() {\n    for await (const b of this.blocks()) {\n      yield b.cid\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
